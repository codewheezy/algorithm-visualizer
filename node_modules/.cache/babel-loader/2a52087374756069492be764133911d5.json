{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/uchennaibe/Desktop/algorithm-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";export var dijkstra=function dijkstra(grid,startNode,endNode){if(startNode===endNode)return false;// create visitedNodesInOrder array to keep track and animate\nvar visitedNodesInOrder=[];// get all the unvisited nodes\nvar unvisitedNodes=getAllNodes(grid);// set startNode distance 0\nstartNode.distance=0;//TODO\nwhile(unvisitedNodes.length){// sort unvisited ascending order and get the first value(shift())\nsortNodesByDistance(unvisitedNodes);var closestNode=unvisitedNodes.shift();if(closestNode.distance===Infinity)return{visitedNodesInOrder:visitedNodesInOrder,success:false};// set closest node as visited and push it to visited nodes in order\nclosestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===endNode)return{visitedNodesInOrder:visitedNodesInOrder,success:true};// update unvisited neighbors\nupdateUnvisitedNeighbors(closestNode,grid);}//TODO do something when failed :(\nconsole.log(\"Failed :(\");};var getAllNodes=function getAllNodes(grid){var nodes=[];var _iterator=_createForOfIteratorHelper(grid),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var row=_step.value;var _iterator2=_createForOfIteratorHelper(row),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var n=_step2.value;nodes.push(n);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return nodes;};var sortNodesByDistance=function sortNodesByDistance(unvisitedNodes){unvisitedNodes.sort(function(nodeA,nodeB){return nodeA.distance-nodeB.distance;});};var updateUnvisitedNeighbors=function updateUnvisitedNeighbors(node,grid){// get unvisited neighbors\nvar unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iterator3=_createForOfIteratorHelper(unvisitedNeighbors),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var neighbor=_step3.value;// increment every neighbor's distance by 1\nneighbor.distance=node.distance+1;// set neighbor's prev node  = current node\nneighbor.previousNode=node;}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}};var getUnvisitedNeighbors=function getUnvisitedNeighbors(node,grid){var neighbors=[];var row=node.row,col=node.col;if(row>0&&!grid[row-1][col].isWall)neighbors.push(grid[row-1][col]);if(row<grid.length-1&&!grid[row+1][col].isWall)neighbors.push(grid[row+1][col]);if(col>0&&!grid[row][col-1].isWall)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1&&!grid[row][col+1].isWall)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});};export var getNodesInShortestPathOrder=function getNodesInShortestPathOrder(endNode){var nodesInShortestPathOrder=[];var currentNode=endNode;while(currentNode){nodesInShortestPathOrder.unshift(currentNode);currentNode=currentNode.previousNode;}// console.log(nodesInShortestPathOrder);\nreturn nodesInShortestPathOrder;};","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/path-finder/pathFinder-algos/dijkstra.js"],"names":["dijkstra","grid","startNode","endNode","visitedNodesInOrder","unvisitedNodes","getAllNodes","distance","length","sortNodesByDistance","closestNode","shift","Infinity","success","isVisited","push","updateUnvisitedNeighbors","console","log","nodes","row","n","sort","nodeA","nodeB","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","isWall","filter","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"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","sourcesContent":["export const dijkstra = (grid, startNode, endNode) => {\n    if (startNode === endNode)\n        return false\n\n    // create visitedNodesInOrder array to keep track and animate\n    const visitedNodesInOrder = []\n\n    // get all the unvisited nodes\n    var unvisitedNodes = getAllNodes(grid)\n    // set startNode distance 0\n    startNode.distance = 0\n    //TODO\n\n    while (unvisitedNodes.length) {\n        // sort unvisited ascending order and get the first value(shift())\n        sortNodesByDistance(unvisitedNodes)\n        const closestNode = unvisitedNodes.shift();\n\n        if (closestNode.distance === Infinity)\n            return { visitedNodesInOrder, success: false }\n\n        // set closest node as visited and push it to visited nodes in order\n        closestNode.isVisited = true\n        visitedNodesInOrder.push(closestNode)\n\n        if (closestNode === endNode)\n            return { visitedNodesInOrder, success: true }\n\n        // update unvisited neighbors\n        updateUnvisitedNeighbors(closestNode, grid)\n    }\n    //TODO do something when failed :(\n    console.log(\"Failed :(\");\n}\n\nconst getAllNodes = (grid) => {\n    const nodes = []\n    for (let row of grid)\n        for (let n of row)\n            nodes.push(n)\n    return nodes\n}\n\nconst sortNodesByDistance = (unvisitedNodes) => {\n\n    unvisitedNodes.sort((nodeA, nodeB) => {\n        return nodeA.distance - nodeB.distance\n    })\n}\nconst updateUnvisitedNeighbors = (node, grid) => {\n    // get unvisited neighbors\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid)\n    for (const neighbor of unvisitedNeighbors) {\n        // increment every neighbor's distance by 1\n        neighbor.distance = node.distance + 1\n        // set neighbor's prev node  = current node\n        neighbor.previousNode = node\n    }\n}\n\nconst getUnvisitedNeighbors = (node, grid) => {\n    const neighbors = []\n    const { row, col } = node\n    if (row > 0 && !grid[row - 1][col].isWall) neighbors.push(grid[row - 1][col])\n    if (row < grid.length - 1 && !grid[row + 1][col].isWall) neighbors.push(grid[row + 1][col])\n    if (col > 0 && !grid[row][col - 1].isWall) neighbors.push(grid[row][col - 1])\n    if (col < grid[0].length - 1 && !grid[row][col + 1].isWall) neighbors.push(grid[row][col + 1])\n    return neighbors.filter(neighbor => !neighbor.isVisited)\n}\n\nexport const getNodesInShortestPathOrder = (endNode) => {\n    let nodesInShortestPathOrder = []\n    let currentNode = endNode\n    while (currentNode) {\n        nodesInShortestPathOrder.unshift(currentNode)\n        currentNode = currentNode.previousNode\n    }\n    // console.log(nodesInShortestPathOrder);\n    return nodesInShortestPathOrder\n}"]},"metadata":{},"sourceType":"module"}