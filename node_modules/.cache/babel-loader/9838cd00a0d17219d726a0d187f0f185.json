{"ast":null,"code":"//advance merge sort using auxiliary array\n// aux array is exact copy of the unsorted array ; \n//unpack the value from aux array and reorganize main_unsorted_array\nvar merge=function merge(main_array,aux_array,low,mid,high,animations){var i=low;//traverse the left part\nvar j=mid+1;// traverse the right part\nvar k=low;//index of aux_array \nwhile(i<=mid&&j<=high){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([i,j]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([i,j]);if(aux_array[i]<aux_array[j]){// We overwrite the value at index k in the original array with the\n// value at index i in the auxiliary array.\n// console.log(\"push overwh\");\nanimations.push([k,aux_array[i]]);main_array[k++]=aux_array[i++];}else{// We overwrite the value at index k in the original array with the\n// value at index j in the auxiliary array.\nanimations.push([k,aux_array[j]]);main_array[k++]=aux_array[j++];}}while(i<=mid){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([i,i]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([i,i]);// We overwrite the value at index k in the original array with the\n// value at index i in the auxiliary array.\nanimations.push([k,aux_array[i]]);main_array[k++]=aux_array[i++];}while(j<=high){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([j,j]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([j,j]);// We overwrite the value at index k in the original array with the\n// value at index i in the auxiliary array.\nanimations.push([k,aux_array[j]]);main_array[k++]=aux_array[j++];}return main_array;};var mergeSort=function mergeSort(array,aux_array,low,high,animations){if(low===high)return;var mid=Math.floor((high+low)/2);mergeSort(aux_array,array,low,mid,animations);mergeSort(aux_array,array,mid+1,high,animations);return merge(array,aux_array,low,mid,high,animations);};export var mergeSort_util=function mergeSort_util(unsorted_array){var animations=[];// it's a list of tuple(i,j): i, j are index where we need to show the animation(i.e: swapping,comparing)\nif(unsorted_array.length<=1)return unsorted_array;// duplicate the array\nvar aux_array=unsorted_array.slice();mergeSort(unsorted_array,aux_array,0,unsorted_array.length-1,animations);// arrays are mutable so mergeSort() overwrites animation array;so return animations array \nreturn animations;};","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/sorting/sorting-algos/merge_sort.js"],"names":["merge","main_array","aux_array","low","mid","high","animations","i","j","k","push","mergeSort","array","Math","floor","mergeSort_util","unsorted_array","length","slice"],"mappings":"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","sourcesContent":["//advance merge sort using auxiliary array\n\n// aux array is exact copy of the unsorted array ; \n//unpack the value from aux array and reorganize main_unsorted_array\nconst merge = (main_array, aux_array, low, mid, high, animations) => {\n\n    let i = low //traverse the left part\n    let j = mid + 1 // traverse the right part\n    let k = low //index of aux_array \n\n    while (i <= mid && j <= high) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, j])\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, j])\n\n        if (aux_array[i] < aux_array[j]) {\n            // We overwrite the value at index k in the original array with the\n            // value at index i in the auxiliary array.\n            // console.log(\"push overwh\");\n\n            animations.push([k, aux_array[i]])\n\n            main_array[k++] = aux_array[i++]\n        }\n        else {\n            // We overwrite the value at index k in the original array with the\n            // value at index j in the auxiliary array.\n            animations.push([k, aux_array[j]])\n\n            main_array[k++] = aux_array[j++]\n        }\n    }\n\n    while (i <= mid) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, i]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, i]);\n        // We overwrite the value at index k in the original array with the\n        // value at index i in the auxiliary array.\n        animations.push([k, aux_array[i]]);\n\n        main_array[k++] = aux_array[i++]\n    }\n    while (j <= high) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([j, j]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([j, j]);\n        // We overwrite the value at index k in the original array with the\n        // value at index i in the auxiliary array.\n        animations.push([k, aux_array[j]]);\n\n        main_array[k++] = aux_array[j++]\n    }\n    return main_array\n}\n\nconst mergeSort = (array, aux_array, low, high, animations) => {\n    if (low === high)\n        return\n    const mid = Math.floor((high + low) / 2)\n\n    mergeSort(aux_array, array, low, mid, animations)\n    mergeSort(aux_array, array, mid + 1, high, animations)\n    return merge(array, aux_array, low, mid, high, animations)\n}\n\nexport const mergeSort_util = (unsorted_array) => {\n    const animations = [] // it's a list of tuple(i,j): i, j are index where we need to show the animation(i.e: swapping,comparing)\n    if (unsorted_array.length <= 1)\n        return unsorted_array\n\n    // duplicate the array\n    const aux_array = unsorted_array.slice()\n\n    mergeSort(unsorted_array, aux_array, 0, unsorted_array.length - 1, animations)\n    // arrays are mutable so mergeSort() overwrites animation array;so return animations array \n\n    return animations\n}"]},"metadata":{},"sourceType":"module"}