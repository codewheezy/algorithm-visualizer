{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/uchennaibe/Desktop/algorithm-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";// f(n) = g(n) + h(n)\n//f[n] represents our current best guess as to\n// how short a path from start to finish can be if it goes through n.\n//gScore is the distance from start to the neighbor through current\n//\nexport var aStar=function aStar(grid,startNode,endNode){console.log(\"a star called\");var openSet=[];var closedSet=[];// create visitedNodesInOrder array to keep track and animate\nvar visitedNodesInOrder=[];openSet.push(startNode);while(openSet.length>0){// get minimum lowest f node from openSet\nvar current=openSet.sort(function(a,b){return a.f-b.f;})[0];if(current.row===endNode.row&&current.col===endNode.col){//     console.log(current.previousNode, endNode.previousNode);\n// const solution = getNodesInShortestPathOrder(current)\nreturn{visitedNodesInOrder:visitedNodesInOrder,success:true};}visitedNodesInOrder.push(current);// remove the node from openSet\nopenSet.splice(0,1);closedSet.push(current);var neighbors_of_current=getNeighbors(current,grid);var _iterator=_createForOfIteratorHelper(neighbors_of_current),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;if(!closedSet.includes(neighbor)){var tempG=current.g+1;if(openSet.includes(neighbor)){if(tempG<neighbor.g){neighbor.g=tempG;}}else{neighbor.g=tempG;openSet.push(neighbor);}neighbor.h=heuristic(neighbor,endNode);neighbor.f=neighbor.g+neighbor.h;neighbor.previousNode=current;}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}console.log(openSet,closedSet);};var getNeighbors=function getNeighbors(node,grid){var neighbors=[];var row=node.row,col=node.col;if(row>0&&!grid[row-1][col].isWall)neighbors.push(grid[row-1][col]);if(row<grid.length-1&&!grid[row+1][col].isWall)neighbors.push(grid[row+1][col]);if(col>0&&!grid[row][col-1].isWall)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1&&!grid[row][col+1].isWall)neighbors.push(grid[row][col+1]);return neighbors;};// Euclidean distance\nvar heuristic=function heuristic(a,b){var d=Math.hypot(b.row-a.row,b.col-a.col);return d;};","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/path-finder/pathFinder-algos/aStar.js"],"names":["aStar","grid","startNode","endNode","console","log","openSet","closedSet","visitedNodesInOrder","push","length","current","sort","a","b","f","row","col","success","splice","neighbors_of_current","getNeighbors","neighbor","includes","tempG","g","h","heuristic","previousNode","node","neighbors","isWall","d","Math","hypot"],"mappings":"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","sourcesContent":["// f(n) = g(n) + h(n)\n//f[n] represents our current best guess as to\n// how short a path from start to finish can be if it goes through n.\n//gScore is the distance from start to the neighbor through current\n//\n\nexport const aStar = (grid, startNode, endNode) => {\n    console.log(\"a star called\");\n    const openSet = []\n    const closedSet = []\n    // create visitedNodesInOrder array to keep track and animate\n    const visitedNodesInOrder = []\n\n    openSet.push(startNode)\n\n    while (openSet.length > 0) {\n        // get minimum lowest f node from openSet\n        let current = openSet.sort((a, b) => a.f - b.f)[0]\n        if (current.row === endNode.row && current.col === endNode.col) {\n            //     console.log(current.previousNode, endNode.previousNode);\n            // const solution = getNodesInShortestPathOrder(current)\n            return { visitedNodesInOrder, success: true }\n        }\n        visitedNodesInOrder.push(current);\n        // remove the node from openSet\n        openSet.splice(0, 1)\n\n        closedSet.push(current)\n        var neighbors_of_current = getNeighbors(current, grid);\n        for (let neighbor of neighbors_of_current) {\n            if (!closedSet.includes(neighbor)) {\n                var tempG = current.g + 1\n\n                if (openSet.includes(neighbor)) {\n                    if (tempG < neighbor.g) {\n                        neighbor.g = tempG\n                    }\n                } else {\n                    neighbor.g = tempG;\n                    openSet.push(neighbor)\n                }\n                neighbor.h = heuristic(neighbor, endNode)\n                neighbor.f = neighbor.g + neighbor.h;\n\n                neighbor.previousNode = current\n            }\n        }\n    }\n    console.log(openSet, closedSet);\n\n}\n\nconst getNeighbors = (node, grid) => {\n    const neighbors = []\n    const { row, col } = node\n    if (row > 0 && !grid[row - 1][col].isWall) neighbors.push(grid[row - 1][col])\n    if (row < grid.length - 1 && !grid[row + 1][col].isWall) neighbors.push(grid[row + 1][col])\n    if (col > 0 && !grid[row][col - 1].isWall) neighbors.push(grid[row][col - 1])\n    if (col < grid[0].length - 1 && !grid[row][col + 1].isWall) neighbors.push(grid[row][col + 1])\n    return neighbors\n}\n\n// Euclidean distance\nconst heuristic = (a, b) => {\n    var d = Math.hypot(b.row - a.row, b.col - a.col)\n    return d\n}\n"]},"metadata":{},"sourceType":"module"}