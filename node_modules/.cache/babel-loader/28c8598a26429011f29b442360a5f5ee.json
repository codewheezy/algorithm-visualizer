{"ast":null,"code":"import { getUnvisitedNeighbors } from \"./util_functions\"; //? might be wrong\n// TODO check dfs algorithm if it is correct\n\nexport const dfs = (grid, startNode, endNode) => {\n  // create visitedNodesInOrder array to keep track and animate\n  const visitedNodesInOrder = [];\n  var stack = [];\n  stack.push(startNode);\n\n  while (stack.length > 0) {\n    const current = stack.pop();\n    console.log(current);\n    current.isVisited = true;\n    visitedNodesInOrder.push(current);\n\n    if (current.row === endNode.row && current.col === endNode.col) {\n      console.log(current.previousNode, endNode.previousNode);\n      return {\n        visitedNodesInOrder,\n        success: true\n      };\n    }\n\n    updateUnvisitedNeighbors(current, grid, stack);\n  } //TODO if success:false\n\n\n  console.log(\"path not found\");\n};\n\nconst updateUnvisitedNeighbors = (node, grid, queue) => {\n  // get unvisited neighbors\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (const neighbor of unvisitedNeighbors) {\n    // set neighbor's prev node  = current node\n    neighbor.previousNode = node; //add it to the queue\n\n    if (!queue.includes(neighbor)) queue.push(neighbor);\n  }\n};","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/path-finder/pathFinder-algos/dfs.js"],"names":["getUnvisitedNeighbors","dfs","grid","startNode","endNode","visitedNodesInOrder","stack","push","length","current","pop","console","log","isVisited","row","col","previousNode","success","updateUnvisitedNeighbors","node","queue","unvisitedNeighbors","neighbor","includes"],"mappings":"AAAA,SAASA,qBAAT,QAAsC,kBAAtC,C,CACA;AACA;;AACA,OAAO,MAAMC,GAAG,GAAG,CAACC,IAAD,EAAOC,SAAP,EAAkBC,OAAlB,KAA8B;AAE7C;AACA,QAAMC,mBAAmB,GAAG,EAA5B;AAEA,MAAIC,KAAK,GAAG,EAAZ;AACAA,EAAAA,KAAK,CAACC,IAAN,CAAWJ,SAAX;;AAEA,SAAOG,KAAK,CAACE,MAAN,GAAe,CAAtB,EAAyB;AACrB,UAAMC,OAAO,GAAGH,KAAK,CAACI,GAAN,EAAhB;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYH,OAAZ;AACAA,IAAAA,OAAO,CAACI,SAAR,GAAoB,IAApB;AACAR,IAAAA,mBAAmB,CAACE,IAApB,CAAyBE,OAAzB;;AAEA,QAAIA,OAAO,CAACK,GAAR,KAAgBV,OAAO,CAACU,GAAxB,IAA+BL,OAAO,CAACM,GAAR,KAAgBX,OAAO,CAACW,GAA3D,EAAgE;AAC5DJ,MAAAA,OAAO,CAACC,GAAR,CAAYH,OAAO,CAACO,YAApB,EAAkCZ,OAAO,CAACY,YAA1C;AACA,aAAO;AAAEX,QAAAA,mBAAF;AAAuBY,QAAAA,OAAO,EAAE;AAAhC,OAAP;AACH;;AACDC,IAAAA,wBAAwB,CAACT,OAAD,EAAUP,IAAV,EAAgBI,KAAhB,CAAxB;AACH,GAnB4C,CAoB7C;;;AACAK,EAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ;AACH,CAtBM;;AAwBP,MAAMM,wBAAwB,GAAG,CAACC,IAAD,EAAOjB,IAAP,EAAakB,KAAb,KAAuB;AACpD;AACA,QAAMC,kBAAkB,GAAGrB,qBAAqB,CAACmB,IAAD,EAAOjB,IAAP,CAAhD;;AACA,OAAK,MAAMoB,QAAX,IAAuBD,kBAAvB,EAA2C;AACvC;AACAC,IAAAA,QAAQ,CAACN,YAAT,GAAwBG,IAAxB,CAFuC,CAGvC;;AACA,QAAI,CAACC,KAAK,CAACG,QAAN,CAAeD,QAAf,CAAL,EACIF,KAAK,CAACb,IAAN,CAAWe,QAAX;AACP;AACJ,CAVD","sourcesContent":["import { getUnvisitedNeighbors } from \"./util_functions\";\n//? might be wrong\n// TODO check dfs algorithm if it is correct\nexport const dfs = (grid, startNode, endNode) => {\n\n    // create visitedNodesInOrder array to keep track and animate\n    const visitedNodesInOrder = []\n\n    var stack = []\n    stack.push(startNode)\n\n    while (stack.length > 0) {\n        const current = stack.pop();\n        console.log(current);\n        current.isVisited = true\n        visitedNodesInOrder.push(current)\n\n        if (current.row === endNode.row && current.col === endNode.col) {\n            console.log(current.previousNode, endNode.previousNode);\n            return { visitedNodesInOrder, success: true }\n        }\n        updateUnvisitedNeighbors(current, grid, stack)\n    }\n    //TODO if success:false\n    console.log(\"path not found\");\n}\n\nconst updateUnvisitedNeighbors = (node, grid, queue) => {\n    // get unvisited neighbors\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid)\n    for (const neighbor of unvisitedNeighbors) {\n        // set neighbor's prev node  = current node\n        neighbor.previousNode = node\n        //add it to the queue\n        if (!queue.includes(neighbor))\n            queue.push(neighbor)\n    }\n}"]},"metadata":{},"sourceType":"module"}