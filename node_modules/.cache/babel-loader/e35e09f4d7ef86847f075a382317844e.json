{"ast":null,"code":"//advance merge sort using auxiliary array\n// aux array is exact copy of the unsorted array ; \n//unpack the value from aux array and reorganize main_unsorted_array\nconst merge = (main_array, aux_array, low, mid, high, animations) => {\n  let i = low; //traverse the left part\n\n  let j = mid + 1; // traverse the right part\n\n  let k = low; //index of aux_array \n\n  while (i <= mid && j <= high) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, j]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([i, j]);\n\n    if (aux_array[i] < aux_array[j]) {\n      // We overwrite the value at index k in the original array with the\n      // value at index i in the auxiliary array.\n      // console.log(\"push overwh\");\n      animations.push([k, aux_array[i]]);\n      main_array[k++] = aux_array[i++];\n    } else {\n      // We overwrite the value at index k in the original array with the\n      // value at index j in the auxiliary array.\n      animations.push([k, aux_array[j]]);\n      main_array[k++] = aux_array[j++];\n    }\n  }\n\n  while (i <= mid) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, i]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([i, i]); // We overwrite the value at index k in the original array with the\n    // value at index i in the auxiliary array.\n\n    animations.push([k, aux_array[i]]);\n    main_array[k++] = aux_array[i++];\n  }\n\n  while (j <= high) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([j, j]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([j, j]); // We overwrite the value at index k in the original array with the\n    // value at index i in the auxiliary array.\n\n    animations.push([k, aux_array[j]]);\n    main_array[k++] = aux_array[j++];\n  }\n\n  return main_array;\n};\n\nconst mergeSort = (array, aux_array, low, high, animations) => {\n  if (low === high) return;\n  const mid = Math.floor((high + low) / 2);\n  mergeSort(aux_array, array, low, mid, animations);\n  mergeSort(aux_array, array, mid + 1, high, animations);\n  return merge(array, aux_array, low, mid, high, animations);\n};\n\nexport const mergeSort_util = unsorted_array => {\n  const animations = []; // it's a list of tuple(i,j): i, j are index where we need to show the animation(i.e: swapping,comparing)\n\n  if (unsorted_array.length <= 1) return unsorted_array; // duplicate the array\n\n  const aux_array = unsorted_array.slice();\n  mergeSort(unsorted_array, aux_array, 0, unsorted_array.length - 1, animations); // arrays are mutable so mergeSort() overwrites animation array;so return animations array \n\n  return animations;\n};","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/sorting/sorting-algos/merge_sort.js"],"names":["merge","main_array","aux_array","low","mid","high","animations","i","j","k","push","mergeSort","array","Math","floor","mergeSort_util","unsorted_array","length","slice"],"mappings":"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","sourcesContent":["//advance merge sort using auxiliary array\n\n// aux array is exact copy of the unsorted array ; \n//unpack the value from aux array and reorganize main_unsorted_array\nconst merge = (main_array, aux_array, low, mid, high, animations) => {\n\n    let i = low //traverse the left part\n    let j = mid + 1 // traverse the right part\n    let k = low //index of aux_array \n\n    while (i <= mid && j <= high) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, j])\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, j])\n\n        if (aux_array[i] < aux_array[j]) {\n            // We overwrite the value at index k in the original array with the\n            // value at index i in the auxiliary array.\n            // console.log(\"push overwh\");\n\n            animations.push([k, aux_array[i]])\n\n            main_array[k++] = aux_array[i++]\n        }\n        else {\n            // We overwrite the value at index k in the original array with the\n            // value at index j in the auxiliary array.\n            animations.push([k, aux_array[j]])\n\n            main_array[k++] = aux_array[j++]\n        }\n    }\n\n    while (i <= mid) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, i]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, i]);\n        // We overwrite the value at index k in the original array with the\n        // value at index i in the auxiliary array.\n        animations.push([k, aux_array[i]]);\n\n        main_array[k++] = aux_array[i++]\n    }\n    while (j <= high) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([j, j]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([j, j]);\n        // We overwrite the value at index k in the original array with the\n        // value at index i in the auxiliary array.\n        animations.push([k, aux_array[j]]);\n\n        main_array[k++] = aux_array[j++]\n    }\n    return main_array\n}\n\nconst mergeSort = (array, aux_array, low, high, animations) => {\n    if (low === high)\n        return\n    const mid = Math.floor((high + low) / 2)\n\n    mergeSort(aux_array, array, low, mid, animations)\n    mergeSort(aux_array, array, mid + 1, high, animations)\n    return merge(array, aux_array, low, mid, high, animations)\n}\n\nexport const mergeSort_util = (unsorted_array) => {\n    const animations = [] // it's a list of tuple(i,j): i, j are index where we need to show the animation(i.e: swapping,comparing)\n    if (unsorted_array.length <= 1)\n        return unsorted_array\n\n    // duplicate the array\n    const aux_array = unsorted_array.slice()\n\n    mergeSort(unsorted_array, aux_array, 0, unsorted_array.length - 1, animations)\n    // arrays are mutable so mergeSort() overwrites animation array;so return animations array \n\n    return animations\n}"]},"metadata":{},"sourceType":"module"}