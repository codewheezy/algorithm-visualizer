{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/uchennaibe/Desktop/algorithm-visualizer/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import{getUnvisitedNeighbors}from\"./util_functions\";//? might be wrong\n// TODO check dfs algorithm if it is correct\nexport var dfs=function dfs(grid,startNode,endNode){// create visitedNodesInOrder array to keep track and animate\nvar visitedNodesInOrder=[];var stack=[];stack.push(startNode);while(stack.length>0){var current=stack.pop();console.log(current);current.isVisited=true;visitedNodesInOrder.push(current);if(current.row===endNode.row&&current.col===endNode.col){console.log(current.previousNode,endNode.previousNode);return{visitedNodesInOrder:visitedNodesInOrder,success:true};}updateUnvisitedNeighbors(current,grid,stack);}//TODO if success:false\nconsole.log(\"path not found\");};var updateUnvisitedNeighbors=function updateUnvisitedNeighbors(node,grid,queue){// get unvisited neighbors\nvar unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iterator=_createForOfIteratorHelper(unvisitedNeighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;// set neighbor's prev node  = current node\nneighbor.previousNode=node;//add it to the queue\nif(!queue.includes(neighbor))queue.push(neighbor);}}catch(err){_iterator.e(err);}finally{_iterator.f();}};","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/path-finder/pathFinder-algos/dfs.js"],"names":["getUnvisitedNeighbors","dfs","grid","startNode","endNode","visitedNodesInOrder","stack","push","length","current","pop","console","log","isVisited","row","col","previousNode","success","updateUnvisitedNeighbors","node","queue","unvisitedNeighbors","neighbor","includes"],"mappings":"yJAAA,OAASA,qBAAT,KAAsC,kBAAtC,CACA;AACA;AACA,MAAO,IAAMC,CAAAA,GAAG,CAAG,QAANA,CAAAA,GAAM,CAACC,IAAD,CAAOC,SAAP,CAAkBC,OAAlB,CAA8B,CAE7C;AACA,GAAMC,CAAAA,mBAAmB,CAAG,EAA5B,CAEA,GAAIC,CAAAA,KAAK,CAAG,EAAZ,CACAA,KAAK,CAACC,IAAN,CAAWJ,SAAX,EAEA,MAAOG,KAAK,CAACE,MAAN,CAAe,CAAtB,CAAyB,CACrB,GAAMC,CAAAA,OAAO,CAAGH,KAAK,CAACI,GAAN,EAAhB,CACAC,OAAO,CAACC,GAAR,CAAYH,OAAZ,EACAA,OAAO,CAACI,SAAR,CAAoB,IAApB,CACAR,mBAAmB,CAACE,IAApB,CAAyBE,OAAzB,EAEA,GAAIA,OAAO,CAACK,GAAR,GAAgBV,OAAO,CAACU,GAAxB,EAA+BL,OAAO,CAACM,GAAR,GAAgBX,OAAO,CAACW,GAA3D,CAAgE,CAC5DJ,OAAO,CAACC,GAAR,CAAYH,OAAO,CAACO,YAApB,CAAkCZ,OAAO,CAACY,YAA1C,EACA,MAAO,CAAEX,mBAAmB,CAAnBA,mBAAF,CAAuBY,OAAO,CAAE,IAAhC,CAAP,CACH,CACDC,wBAAwB,CAACT,OAAD,CAAUP,IAAV,CAAgBI,KAAhB,CAAxB,CACH,CACD;AACAK,OAAO,CAACC,GAAR,CAAY,gBAAZ,EACH,CAtBM,CAwBP,GAAMM,CAAAA,wBAAwB,CAAG,QAA3BA,CAAAA,wBAA2B,CAACC,IAAD,CAAOjB,IAAP,CAAakB,KAAb,CAAuB,CACpD;AACA,GAAMC,CAAAA,kBAAkB,CAAGrB,qBAAqB,CAACmB,IAAD,CAAOjB,IAAP,CAAhD,CAFoD,yCAG7BmB,kBAH6B,YAGpD,+CAA2C,IAAhCC,CAAAA,QAAgC,aACvC;AACAA,QAAQ,CAACN,YAAT,CAAwBG,IAAxB,CACA;AACA,GAAI,CAACC,KAAK,CAACG,QAAN,CAAeD,QAAf,CAAL,CACIF,KAAK,CAACb,IAAN,CAAWe,QAAX,EACP,CATmD,qDAUvD,CAVD","sourcesContent":["import { getUnvisitedNeighbors } from \"./util_functions\";\n//? might be wrong\n// TODO check dfs algorithm if it is correct\nexport const dfs = (grid, startNode, endNode) => {\n\n    // create visitedNodesInOrder array to keep track and animate\n    const visitedNodesInOrder = []\n\n    var stack = []\n    stack.push(startNode)\n\n    while (stack.length > 0) {\n        const current = stack.pop();\n        console.log(current);\n        current.isVisited = true\n        visitedNodesInOrder.push(current)\n\n        if (current.row === endNode.row && current.col === endNode.col) {\n            console.log(current.previousNode, endNode.previousNode);\n            return { visitedNodesInOrder, success: true }\n        }\n        updateUnvisitedNeighbors(current, grid, stack)\n    }\n    //TODO if success:false\n    console.log(\"path not found\");\n}\n\nconst updateUnvisitedNeighbors = (node, grid, queue) => {\n    // get unvisited neighbors\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid)\n    for (const neighbor of unvisitedNeighbors) {\n        // set neighbor's prev node  = current node\n        neighbor.previousNode = node\n        //add it to the queue\n        if (!queue.includes(neighbor))\n            queue.push(neighbor)\n    }\n}"]},"metadata":{},"sourceType":"module"}