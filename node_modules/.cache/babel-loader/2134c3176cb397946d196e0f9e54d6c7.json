{"ast":null,"code":"// f(n) = g(n) + h(n)\n//f[n] represents our current best guess as to\n// how short a path from start to finish can be if it goes through n.\n//gScore is the distance from start to the neighbor through current\n//\nexport const aStar = (grid, startNode, endNode) => {\n  console.log(\"a star called\");\n  const openSet = [];\n  const closedSet = []; // create visitedNodesInOrder array to keep track and animate\n\n  const visitedNodesInOrder = [];\n  openSet.push(startNode);\n\n  while (openSet.length > 0) {\n    // get minimum lowest f node from openSet\n    let current = openSet.sort((a, b) => a.f - b.f)[0];\n\n    if (current.row === endNode.row && current.col === endNode.col) {\n      //     console.log(current.previousNode, endNode.previousNode);\n      // const solution = getNodesInShortestPathOrder(current)\n      return {\n        visitedNodesInOrder,\n        success: true\n      };\n    }\n\n    visitedNodesInOrder.push(current); // remove the node from openSet\n\n    openSet.splice(0, 1);\n    closedSet.push(current);\n    var neighbors_of_current = getNeighbors(current, grid);\n\n    for (let neighbor of neighbors_of_current) {\n      if (!closedSet.includes(neighbor)) {\n        var tempG = current.g + 1;\n\n        if (openSet.includes(neighbor)) {\n          if (tempG < neighbor.g) {\n            neighbor.g = tempG;\n          }\n        } else {\n          neighbor.g = tempG;\n          openSet.push(neighbor);\n        }\n\n        neighbor.h = heuristic(neighbor, endNode);\n        neighbor.f = neighbor.g + neighbor.h;\n        neighbor.previousNode = current;\n      }\n    }\n  }\n\n  console.log(openSet, closedSet);\n};\n\nconst getNeighbors = (node, grid) => {\n  const neighbors = [];\n  const {\n    row,\n    col\n  } = node;\n  if (row > 0 && !grid[row - 1][col].isWall) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1 && !grid[row + 1][col].isWall) neighbors.push(grid[row + 1][col]);\n  if (col > 0 && !grid[row][col - 1].isWall) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1 && !grid[row][col + 1].isWall) neighbors.push(grid[row][col + 1]);\n  return neighbors;\n}; // Euclidean distance\n\n\nconst heuristic = (a, b) => {\n  var d = Math.hypot(b.row - a.row, b.col - a.col);\n  return d;\n};","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/path-finder/pathFinder-algos/aStar.js"],"names":["aStar","grid","startNode","endNode","console","log","openSet","closedSet","visitedNodesInOrder","push","length","current","sort","a","b","f","row","col","success","splice","neighbors_of_current","getNeighbors","neighbor","includes","tempG","g","h","heuristic","previousNode","node","neighbors","isWall","d","Math","hypot"],"mappings":"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","sourcesContent":["// f(n) = g(n) + h(n)\n//f[n] represents our current best guess as to\n// how short a path from start to finish can be if it goes through n.\n//gScore is the distance from start to the neighbor through current\n//\n\nexport const aStar = (grid, startNode, endNode) => {\n    console.log(\"a star called\");\n    const openSet = []\n    const closedSet = []\n    // create visitedNodesInOrder array to keep track and animate\n    const visitedNodesInOrder = []\n\n    openSet.push(startNode)\n\n    while (openSet.length > 0) {\n        // get minimum lowest f node from openSet\n        let current = openSet.sort((a, b) => a.f - b.f)[0]\n        if (current.row === endNode.row && current.col === endNode.col) {\n            //     console.log(current.previousNode, endNode.previousNode);\n            // const solution = getNodesInShortestPathOrder(current)\n            return { visitedNodesInOrder, success: true }\n        }\n        visitedNodesInOrder.push(current);\n        // remove the node from openSet\n        openSet.splice(0, 1)\n\n        closedSet.push(current)\n        var neighbors_of_current = getNeighbors(current, grid);\n        for (let neighbor of neighbors_of_current) {\n            if (!closedSet.includes(neighbor)) {\n                var tempG = current.g + 1\n\n                if (openSet.includes(neighbor)) {\n                    if (tempG < neighbor.g) {\n                        neighbor.g = tempG\n                    }\n                } else {\n                    neighbor.g = tempG;\n                    openSet.push(neighbor)\n                }\n                neighbor.h = heuristic(neighbor, endNode)\n                neighbor.f = neighbor.g + neighbor.h;\n\n                neighbor.previousNode = current\n            }\n        }\n    }\n    console.log(openSet, closedSet);\n\n}\n\nconst getNeighbors = (node, grid) => {\n    const neighbors = []\n    const { row, col } = node\n    if (row > 0 && !grid[row - 1][col].isWall) neighbors.push(grid[row - 1][col])\n    if (row < grid.length - 1 && !grid[row + 1][col].isWall) neighbors.push(grid[row + 1][col])\n    if (col > 0 && !grid[row][col - 1].isWall) neighbors.push(grid[row][col - 1])\n    if (col < grid[0].length - 1 && !grid[row][col + 1].isWall) neighbors.push(grid[row][col + 1])\n    return neighbors\n}\n\n// Euclidean distance\nconst heuristic = (a, b) => {\n    var d = Math.hypot(b.row - a.row, b.col - a.col)\n    return d\n}\n"]},"metadata":{},"sourceType":"module"}