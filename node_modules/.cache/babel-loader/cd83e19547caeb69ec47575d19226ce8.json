{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/uchennaibe/Desktop/algorithm-visualizer/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import{getUnvisitedNeighbors}from\"./util_functions\";export var bfs=function bfs(grid,startNode,endNode){// create visitedNodesInOrder array to keep track and animate\nvar visitedNodesInOrder=[];var queue=[];queue.push(startNode);while(queue.length>0){var current=queue.shift();current.isVisited=true;visitedNodesInOrder.push(current);if(current.row===endNode.row&&current.col===endNode.col){console.log(\"done\");return{visitedNodesInOrder:visitedNodesInOrder,success:true};}updateUnvisitedNeighbors(current,grid,queue);}//TODO return success:false(if not found)\nconsole.log(\"path not found\");};var updateUnvisitedNeighbors=function updateUnvisitedNeighbors(node,grid,queue){// get unvisited neighbors\nvar unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iterator=_createForOfIteratorHelper(unvisitedNeighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;// set neighbor's prev node  = current node\nneighbor.previousNode=node;//add it to the queue\nif(!queue.includes(neighbor))queue.push(neighbor);}}catch(err){_iterator.e(err);}finally{_iterator.f();}};","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/path-finder/pathFinder-algos/bfs.js"],"names":["getUnvisitedNeighbors","bfs","grid","startNode","endNode","visitedNodesInOrder","queue","push","length","current","shift","isVisited","row","col","console","log","success","updateUnvisitedNeighbors","node","unvisitedNeighbors","neighbor","previousNode","includes"],"mappings":"yJAAA,OAASA,qBAAT,KAAsC,kBAAtC,CAEA,MAAO,IAAMC,CAAAA,GAAG,CAAG,QAANA,CAAAA,GAAM,CAACC,IAAD,CAAOC,SAAP,CAAkBC,OAAlB,CAA8B,CAC7C;AACA,GAAMC,CAAAA,mBAAmB,CAAG,EAA5B,CACA,GAAIC,CAAAA,KAAK,CAAG,EAAZ,CACAA,KAAK,CAACC,IAAN,CAAWJ,SAAX,EAEA,MAAOG,KAAK,CAACE,MAAN,CAAe,CAAtB,CAAyB,CACrB,GAAMC,CAAAA,OAAO,CAAGH,KAAK,CAACI,KAAN,EAAhB,CACAD,OAAO,CAACE,SAAR,CAAoB,IAApB,CACAN,mBAAmB,CAACE,IAApB,CAAyBE,OAAzB,EACA,GAAIA,OAAO,CAACG,GAAR,GAAgBR,OAAO,CAACQ,GAAxB,EAA+BH,OAAO,CAACI,GAAR,GAAgBT,OAAO,CAACS,GAA3D,CAAgE,CAC5DC,OAAO,CAACC,GAAR,CAAY,MAAZ,EACA,MAAO,CAAEV,mBAAmB,CAAnBA,mBAAF,CAAuBW,OAAO,CAAE,IAAhC,CAAP,CACH,CACDC,wBAAwB,CAACR,OAAD,CAAUP,IAAV,CAAgBI,KAAhB,CAAxB,CACH,CACD;AACAQ,OAAO,CAACC,GAAR,CAAY,gBAAZ,EACH,CAlBM,CAoBP,GAAME,CAAAA,wBAAwB,CAAG,QAA3BA,CAAAA,wBAA2B,CAACC,IAAD,CAAOhB,IAAP,CAAaI,KAAb,CAAuB,CACpD;AACA,GAAMa,CAAAA,kBAAkB,CAAGnB,qBAAqB,CAACkB,IAAD,CAAOhB,IAAP,CAAhD,CAFoD,yCAG7BiB,kBAH6B,YAGpD,+CAA2C,IAAhCC,CAAAA,QAAgC,aACvC;AACAA,QAAQ,CAACC,YAAT,CAAwBH,IAAxB,CACA;AACA,GAAI,CAACZ,KAAK,CAACgB,QAAN,CAAeF,QAAf,CAAL,CACId,KAAK,CAACC,IAAN,CAAWa,QAAX,EACP,CATmD,qDAUvD,CAVD","sourcesContent":["import { getUnvisitedNeighbors } from \"./util_functions\";\n\nexport const bfs = (grid, startNode, endNode) => {\n    // create visitedNodesInOrder array to keep track and animate\n    const visitedNodesInOrder = []\n    var queue = []\n    queue.push(startNode)\n\n    while (queue.length > 0) {\n        const current = queue.shift();\n        current.isVisited = true\n        visitedNodesInOrder.push(current)\n        if (current.row === endNode.row && current.col === endNode.col) {\n            console.log(\"done\");\n            return { visitedNodesInOrder, success: true }\n        }\n        updateUnvisitedNeighbors(current, grid, queue)\n    }\n    //TODO return success:false(if not found)\n    console.log(\"path not found\");\n}\n\nconst updateUnvisitedNeighbors = (node, grid, queue) => {\n    // get unvisited neighbors\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid)\n    for (const neighbor of unvisitedNeighbors) {\n        // set neighbor's prev node  = current node\n        neighbor.previousNode = node\n        //add it to the queue\n        if (!queue.includes(neighbor))\n            queue.push(neighbor)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}