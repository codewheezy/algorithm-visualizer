{"ast":null,"code":"import _objectSpread from\"/Users/uchennaibe/Desktop/algorithm-visualizer/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/Users/uchennaibe/Desktop/algorithm-visualizer/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{useEffect,useState}from'react';import Node from'./node/Node';import'./pathFinder.css';import{getNodesInShortestPathOrder,dijkstra}from'./pathFinder-algos/dijkstra';import{aStar}from'./pathFinder-algos/aStar';import{bfs}from'./pathFinder-algos/bfs';import{dfs}from'./pathFinder-algos/dfs';import{motion}from'framer-motion';import useWindowSize from'../hooks/windowResize';import{toast}from'react-toastify';import{variants}from'../framer motion/variants';var ROWS=13;// var COLS = 25;\nvar CURRENT_START_NODE_ROW=0;var CURRENT_START_NODE_COL=8;var CURRENT_END_NODE_ROW=8;var CURRENT_END_NODE_COL=0;var PathFinder=function PathFinder(){var _useState=useState([]),_useState2=_slicedToArray(_useState,2),mainGrid=_useState2[0],setMainGrid=_useState2[1];var _useState3=useState(false),_useState4=_slicedToArray(_useState3,2),mouseIsPressed=_useState4[0],setMouseIsPressed=_useState4[1];var _useState5=useState(false),_useState6=_slicedToArray(_useState5,2),isStartNode=_useState6[0],setIsStartNode=_useState6[1];var _useState7=useState(false),_useState8=_slicedToArray(_useState7,2),isEndNode=_useState8[0],setIsEndNode=_useState8[1];//TODO different cols for different screen\nvar _useState9=useState(15),_useState10=_slicedToArray(_useState9,2),COLS=_useState10[0],SET_COLS=_useState10[1];var _useState11=useState(false),_useState12=_slicedToArray(_useState11,2),alreadyRan=_useState12[0],setAlreadyRan=_useState12[1];// false if the algo is running first time\n// else if the algorithm is already ran ; set it true and remove all the node's distance\nvar _useState13=useState(false),_useState14=_slicedToArray(_useState13,2),notified=_useState14[0],setNotified=_useState14[1];// const [algoDone, setAlgoDone] = useState(false)\nvar _useState15=useState(null),_useState16=_slicedToArray(_useState15,2),currentAlgo=_useState16[0],setCurrentAlgo=_useState16[1];var _useState17=useState(false),_useState18=_slicedToArray(_useState17,2),prevNodeIsWall=_useState18[0],setPrevNodeIsWall=_useState18[1];var createNode=function createNode(row,col){return{row:row,col:col,isStart:row===CURRENT_START_NODE_ROW&&col===CURRENT_START_NODE_COL,isEnd:row===CURRENT_END_NODE_ROW&&col===CURRENT_END_NODE_COL,distance:Infinity,isVisited:false,previousNode:null,isWall:false,// for aStar algorithm\nf:0,g:0,h:0};};var createInitialGrid=function createInitialGrid(){var temp_grid=[];for(var row=0;row<ROWS;row++){var currentRow=[];for(var col=0;col<COLS;col++){currentRow.push(createNode(row,col));}temp_grid.push(currentRow);}return temp_grid;};//component did mount\nuseEffect(function(){if(window.innerWidth<500&&!notified){toast.warn('Seems like you are using this app in mobile :( Open this app in large screen to get the best experience :)',{autoClose:false});}setNotified(true);setMainGrid(createInitialGrid());},[COLS,notified]);var _useWindowSize=useWindowSize(),_useWindowSize2=_slicedToArray(_useWindowSize,1),width=_useWindowSize2[0];if(width<500&&COLS!==15){SET_COLS(15);}else if(width>=500&&width<=1024&&COLS!==20){SET_COLS(20);}else if(width>1024&&COLS!==25){SET_COLS(25);}//! MOUSE DOWN -> MOUSE ENTER -> MOUSE UP\n// MOUSE DOWN : if the node is a start or end node(user wants to set a new start/end node),\n// then we need to remove* the current start node add the new start node\n// BUT , if it is neither a start or end node,then convert it to a wall or toggle it\nvar handleMouseDown=function handleMouseDown(row,col){var newGrid;// check if the element to be dragged is a start or end node\nif(row===CURRENT_START_NODE_ROW&&col===CURRENT_START_NODE_COL)setIsStartNode(true);//set the state variable (flag)\nelse if(row===CURRENT_END_NODE_ROW&&col===CURRENT_END_NODE_COL)setIsEndNode(true);//set the state variable(flag)\nelse{// else toggle isWall property of that node and update the mainGrid\nnewGrid=getNewGridWallToggled(mainGrid,row,col);setMainGrid(newGrid);}// set mouseIsPressed flag is true;now if user hover over any nodes; that will converted\n// to a start node or end node or a wall (toggled)\nsetMouseIsPressed(true);};var handleMouseEnter=function handleMouseEnter(row,col){var newGrid;if(!mouseIsPressed)return;// return if mousePressed flag is not true (down first)\nif(isStartNode===true){newGrid=getNewStart(mainGrid,row,col);}else if(isEndNode===true)newGrid=getNewEnd(mainGrid,row,col);else newGrid=getNewGridWallToggled(mainGrid,row,col);// update the mainGrid\nsetMainGrid(newGrid);};// when leave the mouse , reset the flags to false\nvar handleMouseUp=function handleMouseUp(){setMouseIsPressed(false);if((isStartNode||isEndNode)&&alreadyRan){getAnimateArray(currentAlgo);}setIsStartNode(false);setIsEndNode(false);};var getNewGridWallToggled=function getNewGridWallToggled(grid,row,col){var newGrid=grid.slice();var node=newGrid[row][col];var newNode=_objectSpread(_objectSpread({},node),{},{isWall:!node.isWall});newGrid[row][col]=newNode;return newGrid;};// toggle the start when dragged\nvar getNewStart=function getNewStart(grid,row,col){var newGrid=grid.slice();var new_node=newGrid[row][col];var prev_node=newGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL];var prevNode=_objectSpread(_objectSpread({},prev_node),{},{isStart:false,isWall:prevNodeIsWall});setPrevNodeIsWall(new_node.isWall);var newNode=_objectSpread(_objectSpread({},new_node),{},{isWall:false,isStart:true});newGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL]=prevNode;newGrid[row][col]=newNode;//  console.log(newGrid);\n// update previous variables with current row and current col\nCURRENT_START_NODE_ROW=row;CURRENT_START_NODE_COL=col;return newGrid;};var getNewEnd=function getNewEnd(grid,row,col){var newGrid=grid.slice();var new_node=newGrid[row][col];var prev_node=newGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];//previous node\nvar prevNode=_objectSpread(_objectSpread({},prev_node),{},{isEnd:false,isWall:prevNodeIsWall});setPrevNodeIsWall(new_node.isWall);var newNode=_objectSpread(_objectSpread({},new_node),{},{isWall:false,isEnd:true});newGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL]=prevNode;newGrid[row][col]=newNode;// update previous variables with current row and current col\nCURRENT_END_NODE_ROW=row;CURRENT_END_NODE_COL=col;return newGrid;};var reArrangeGrid=function reArrangeGrid(grid){// make sure don't reset the walls\nvar newGrid=grid.slice();var node;for(var row=0;row<ROWS;row++){for(var col=0;col<COLS;col++){node=newGrid[row][col];var newNode=_objectSpread(_objectSpread({},node),{},{distance:Infinity,isVisited:false,previousNode:null});newGrid[row][col]=newNode;}}return newGrid;};var resetColors=function resetColors(){var nodes=document.getElementsByClassName(\"node\");for(var i=0;i<nodes.length;i++){nodes[i].classList.remove(\"node-visited\");nodes[i].classList.remove(\"node-shortest-path\");}};var resetGrid=function resetGrid(){setMainGrid(createInitialGrid());resetColors();};var animateShortestPath=function animateShortestPath(nodesInShortestPathOrder){var _loop=function _loop(i){setTimeout(function(){var _nodesInShortestPathO=nodesInShortestPathOrder[i],row=_nodesInShortestPathO.row,col=_nodesInShortestPathO.col;document.getElementById(\"node-\".concat(row,\"-\").concat(col)).classList.add('node-shortest-path');},i*100);};for(var i=0;i<nodesInShortestPathOrder.length;i++){_loop(i);}};var animateTraversal=function animateTraversal(visitedNodesInOrder){var nodesInShortestPathOrder=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;var _loop2=function _loop2(i){setTimeout(function(){if(i===visitedNodesInOrder.length-1){if(nodesInShortestPathOrder)animateShortestPath(nodesInShortestPathOrder);}},i*20);setTimeout(function(){var _visitedNodesInOrder$=visitedNodesInOrder[i],row=_visitedNodesInOrder$.row,col=_visitedNodesInOrder$.col;document.getElementById(\"node-\".concat(row,\"-\").concat(col)).classList.add('node-visited');},i*20);};for(var i=0;i<visitedNodesInOrder.length;i++){_loop2(i);}if(!nodesInShortestPathOrder){toast.info('No path found 🐹',{position:'top-center'});}};//TODO Re Re Re Re Re ................... rename the functions :(\nvar reRun=function reRun(){resetColors();setMainGrid(reArrangeGrid(mainGrid));};//TODO notify when path is not found \nvar getAnimateArray=function getAnimateArray(algorithm){var startNode,endNode,visitedNodesInOrder,success;if(algorithm==='dijkstra'){if(alreadyRan){reRun();}startNode=mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL];endNode=mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];// object destructuring and store in already defined variables\nvar _dijkstra=dijkstra(mainGrid,startNode,endNode);visitedNodesInOrder=_dijkstra.visitedNodesInOrder;success=_dijkstra.success;setAlreadyRan(true);setCurrentAlgo('dijkstra');}else if(algorithm==='aStar'){if(alreadyRan){reRun();}startNode=mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL];endNode=mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];var _aStar=aStar(mainGrid,startNode,endNode);visitedNodesInOrder=_aStar.visitedNodesInOrder;success=_aStar.success;setAlreadyRan(true);setCurrentAlgo('aStar');}else if(algorithm==='BFS'){if(alreadyRan){reRun();}startNode=mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL];endNode=mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];var _bfs=bfs(mainGrid,startNode,endNode);visitedNodesInOrder=_bfs.visitedNodesInOrder;success=_bfs.success;setAlreadyRan(true);setCurrentAlgo('BFS');}else if(algorithm==='DFS'){if(alreadyRan){reRun();}startNode=mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL];endNode=mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];var _dfs=dfs(mainGrid,startNode,endNode);visitedNodesInOrder=_dfs.visitedNodesInOrder;success=_dfs.success;setAlreadyRan(true);setCurrentAlgo('DFS');}//console.log(visitedNodesInOrder, success);\nvar nodesInShortestPathOrder;if(success){nodesInShortestPathOrder=getNodesInShortestPathOrder(endNode);}animateTraversal(visitedNodesInOrder,nodesInShortestPathOrder);};return/*#__PURE__*/React.createElement(motion.div,{className:\"pathFinder\",variants:variants,initial:\"hidden\",animate:\"visible\",exit:\"exit\"},/*#__PURE__*/React.createElement(\"div\",{className:\"pathFinder__navbar\"},/*#__PURE__*/React.createElement(\"div\",{className:\"util__buttons\"},/*#__PURE__*/React.createElement(\"button\",{onClick:function onClick(){return resetGrid();}},\"Clear Board\"),/*#__PURE__*/React.createElement(\"button\",{onClick:function onClick(){return toast.dark('⛔ Not implemented yet',{position:'top-center',closeButton:false,autoClose:3000});}},\"Start Timer\")),/*#__PURE__*/React.createElement(\"div\",{className:\"pathFinder__types\"},/*#__PURE__*/React.createElement(\"button\",{className:currentAlgo==='aStar'?'pathFinder__button-active':null,onClick:function onClick(){return getAnimateArray('aStar');}},\" A-star\"),/*#__PURE__*/React.createElement(\"button\",{className:currentAlgo==='dijkstra'?'pathFinder__button-active':null,onClick:function onClick(){return getAnimateArray('dijkstra');}},\"Dijkstra \"),/*#__PURE__*/React.createElement(\"button\",{className:currentAlgo==='DFS'?'pathFinder__button-active':null,onClick:function onClick(){return getAnimateArray('DFS');}},\"DFS\"),/*#__PURE__*/React.createElement(\"button\",{className:currentAlgo==='BFS'?'pathFinder__button-active':null,onClick:function onClick(){return getAnimateArray('BFS');}},\"BFS\"))),/*#__PURE__*/React.createElement(\"div\",{className:\"pathFinder__container\"},/*#__PURE__*/React.createElement(\"div\",{className:\"pathFinder__grid\"},mainGrid.map(function(row,j){return/*#__PURE__*/React.createElement(\"div\",{className:\"grid__row\",key:j},row.map(function(node,i){return/*#__PURE__*/React.createElement(Node,{key:i,node:node,handleMouseUp:handleMouseUp,handleMouseDown:handleMouseDown,handleMouseEnter:handleMouseEnter});}));})),/*#__PURE__*/React.createElement(\"div\",{className:\"indicators\"},/*#__PURE__*/React.createElement(\"div\",{className:\"start\"},/*#__PURE__*/React.createElement(\"i\",{class:\"fas fa-car mr-2\"}),/*#__PURE__*/React.createElement(\"strong\",null,\"Start Node\")),/*#__PURE__*/React.createElement(\"div\",{className:\"end\"},/*#__PURE__*/React.createElement(\"i\",{class:\"fas fa-flag-checkered mr-2\"}),/*#__PURE__*/React.createElement(\"strong\",null,\"End Node\")),/*#__PURE__*/React.createElement(\"div\",{className:\"wall\"},/*#__PURE__*/React.createElement(\"div\",{className:\"wall__icon\"}),/*#__PURE__*/React.createElement(\"strong\",null,\"Wall\")),/*#__PURE__*/React.createElement(\"div\",{className:\"shortestPath\"},/*#__PURE__*/React.createElement(\"div\",{className:\"path__icon\"}),/*#__PURE__*/React.createElement(\"strong\",null,\"Shortest Path\")),/*#__PURE__*/React.createElement(\"div\",{className:\"visited\"},/*#__PURE__*/React.createElement(\"div\",{className:\"visited__icon\"}),/*#__PURE__*/React.createElement(\"strong\",null,\"Visited Node\")))));};export default PathFinder;","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/path-finder/PathFinder.js"],"names":["React","useEffect","useState","Node","getNodesInShortestPathOrder","dijkstra","aStar","bfs","dfs","motion","useWindowSize","toast","variants","ROWS","CURRENT_START_NODE_ROW","CURRENT_START_NODE_COL","CURRENT_END_NODE_ROW","CURRENT_END_NODE_COL","PathFinder","mainGrid","setMainGrid","mouseIsPressed","setMouseIsPressed","isStartNode","setIsStartNode","isEndNode","setIsEndNode","COLS","SET_COLS","alreadyRan","setAlreadyRan","notified","setNotified","currentAlgo","setCurrentAlgo","prevNodeIsWall","setPrevNodeIsWall","createNode","row","col","isStart","isEnd","distance","Infinity","isVisited","previousNode","isWall","f","g","h","createInitialGrid","temp_grid","currentRow","push","window","innerWidth","warn","autoClose","width","handleMouseDown","newGrid","getNewGridWallToggled","handleMouseEnter","getNewStart","getNewEnd","handleMouseUp","getAnimateArray","grid","slice","node","newNode","new_node","prev_node","prevNode","reArrangeGrid","resetColors","nodes","document","getElementsByClassName","i","length","classList","remove","resetGrid","animateShortestPath","nodesInShortestPathOrder","setTimeout","getElementById","add","animateTraversal","visitedNodesInOrder","undefined","info","position","reRun","algorithm","startNode","endNode","success","dark","closeButton","map","j"],"mappings":"iQAAA,MAAOA,CAAAA,KAAP,EAAgBC,SAAhB,CAA2BC,QAA3B,KAA2C,OAA3C,CACA,MAAOC,CAAAA,IAAP,KAAiB,aAAjB,CACA,MAAO,kBAAP,CACA,OAASC,2BAAT,CAAsCC,QAAtC,KAAsD,6BAAtD,CACA,OAASC,KAAT,KAAsB,0BAAtB,CACA,OAASC,GAAT,KAAoB,wBAApB,CACA,OAASC,GAAT,KAAoB,wBAApB,CACA,OAASC,MAAT,KAAuB,eAAvB,CACA,MAAOC,CAAAA,aAAP,KAA0B,uBAA1B,CACA,OAASC,KAAT,KAAsB,gBAAtB,CACA,OAASC,QAAT,KAAyB,2BAAzB,CAEA,GAAIC,CAAAA,IAAI,CAAG,EAAX,CACA;AAEA,GAAIC,CAAAA,sBAAsB,CAAG,CAA7B,CACA,GAAIC,CAAAA,sBAAsB,CAAG,CAA7B,CACA,GAAIC,CAAAA,oBAAoB,CAAG,CAA3B,CACA,GAAIC,CAAAA,oBAAoB,CAAG,CAA3B,CAGA,GAAMC,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,EAAM,eAEWhB,QAAQ,CAAC,EAAD,CAFnB,wCAEdiB,QAFc,eAEJC,WAFI,8BAGuBlB,QAAQ,CAAC,KAAD,CAH/B,yCAGdmB,cAHc,eAGEC,iBAHF,8BAIiBpB,QAAQ,CAAC,KAAD,CAJzB,yCAIdqB,WAJc,eAIDC,cAJC,8BAKatB,QAAQ,CAAC,KAAD,CALrB,yCAKduB,SALc,eAKHC,YALG,eAMrB;AANqB,eAOIxB,QAAQ,CAAC,EAAD,CAPZ,0CAOdyB,IAPc,gBAORC,QAPQ,gCAQe1B,QAAQ,CAAC,KAAD,CARvB,2CAQd2B,UARc,gBAQFC,aARE,gBAQgC;AACrD;AATqB,gBAUW5B,QAAQ,CAAC,KAAD,CAVnB,2CAUd6B,QAVc,gBAUJC,WAVI,gBAWrB;AAXqB,gBAYiB9B,QAAQ,CAAC,IAAD,CAZzB,2CAYd+B,WAZc,gBAYDC,cAZC,gCAcuBhC,QAAQ,CAAC,KAAD,CAd/B,2CAcdiC,cAdc,gBAcEC,iBAdF,gBAkBrB,GAAMC,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAACC,GAAD,CAAMC,GAAN,CAAc,CAC7B,MAAO,CACHD,GAAG,CAAHA,GADG,CAEHC,GAAG,CAAHA,GAFG,CAGHC,OAAO,CAAEF,GAAG,GAAKxB,sBAAR,EAAkCyB,GAAG,GAAKxB,sBAHhD,CAIH0B,KAAK,CAAEH,GAAG,GAAKtB,oBAAR,EAAgCuB,GAAG,GAAKtB,oBAJ5C,CAKHyB,QAAQ,CAAEC,QALP,CAMHC,SAAS,CAAE,KANR,CAOHC,YAAY,CAAE,IAPX,CAQHC,MAAM,CAAE,KARL,CASH;AACAC,CAAC,CAAE,CAVA,CAWHC,CAAC,CAAE,CAXA,CAYHC,CAAC,CAAE,CAZA,CAAP,CAcH,CAfD,CAiBA,GAAMC,CAAAA,iBAAiB,CAAG,QAApBA,CAAAA,iBAAoB,EAAM,CAC5B,GAAIC,CAAAA,SAAS,CAAG,EAAhB,CACA,IAAK,GAAIb,CAAAA,GAAG,CAAG,CAAf,CAAkBA,GAAG,CAAGzB,IAAxB,CAA8ByB,GAAG,EAAjC,CAAqC,CACjC,GAAIc,CAAAA,UAAU,CAAG,EAAjB,CACA,IAAK,GAAIb,CAAAA,GAAG,CAAG,CAAf,CAAkBA,GAAG,CAAGZ,IAAxB,CAA8BY,GAAG,EAAjC,CAAqC,CACjCa,UAAU,CAACC,IAAX,CAAgBhB,UAAU,CAACC,GAAD,CAAMC,GAAN,CAA1B,EACH,CACDY,SAAS,CAACE,IAAV,CAAeD,UAAf,EACH,CACD,MAAOD,CAAAA,SAAP,CACH,CAVD,CAYA;AACAlD,SAAS,CAAC,UAAM,CACZ,GAAIqD,MAAM,CAACC,UAAP,CAAoB,GAApB,EAA2B,CAACxB,QAAhC,CAA0C,CACtCpB,KAAK,CAAC6C,IAAN,CAAW,4GAAX,CACI,CAAEC,SAAS,CAAE,KAAb,CADJ,EAEH,CACDzB,WAAW,CAAC,IAAD,CAAX,CACAZ,WAAW,CAAC8B,iBAAiB,EAAlB,CAAX,CACH,CAPQ,CAON,CAACvB,IAAD,CAAOI,QAAP,CAPM,CAAT,CAhDqB,mBAwDLrB,aAAa,EAxDR,kDAwDdgD,KAxDc,oBAyDrB,GAAIA,KAAK,CAAG,GAAR,EAAe/B,IAAI,GAAK,EAA5B,CAAgC,CAC5BC,QAAQ,CAAC,EAAD,CAAR,CACH,CAFD,IAGK,IAAI8B,KAAK,EAAI,GAAT,EAAgBA,KAAK,EAAI,IAAzB,EAAiC/B,IAAI,GAAK,EAA9C,CAAkD,CACnDC,QAAQ,CAAC,EAAD,CAAR,CACH,CAFI,IAGA,IAAI8B,KAAK,CAAG,IAAR,EAAgB/B,IAAI,GAAK,EAA7B,CAAiC,CAClCC,QAAQ,CAAC,EAAD,CAAR,CACH,CAID;AACA;AACA;AACA;AACA,GAAM+B,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,CAACrB,GAAD,CAAMC,GAAN,CAAc,CAClC,GAAIqB,CAAAA,OAAJ,CACA;AACA,GAAItB,GAAG,GAAKxB,sBAAR,EAAkCyB,GAAG,GAAKxB,sBAA9C,CACIS,cAAc,CAAC,IAAD,CAAd,CAAsB;AAD1B,IAEK,IAAIc,GAAG,GAAKtB,oBAAR,EAAgCuB,GAAG,GAAKtB,oBAA5C,CACDS,YAAY,CAAC,IAAD,CAAZ,CAAoB;AADnB,IAEA,CACD;AACAkC,OAAO,CAAGC,qBAAqB,CAAC1C,QAAD,CAAWmB,GAAX,CAAgBC,GAAhB,CAA/B,CACAnB,WAAW,CAACwC,OAAD,CAAX,CACH,CACD;AACA;AACAtC,iBAAiB,CAAC,IAAD,CAAjB,CACH,CAfD,CAiBA,GAAMwC,CAAAA,gBAAgB,CAAG,QAAnBA,CAAAA,gBAAmB,CAACxB,GAAD,CAAMC,GAAN,CAAc,CACnC,GAAIqB,CAAAA,OAAJ,CAEA,GAAI,CAACvC,cAAL,CAAqB,OAAO;AAE5B,GAAIE,WAAW,GAAK,IAApB,CAA0B,CACtBqC,OAAO,CAAGG,WAAW,CAAC5C,QAAD,CAAWmB,GAAX,CAAgBC,GAAhB,CAArB,CACH,CAFD,IAGK,IAAId,SAAS,GAAK,IAAlB,CACDmC,OAAO,CAAGI,SAAS,CAAC7C,QAAD,CAAWmB,GAAX,CAAgBC,GAAhB,CAAnB,CADC,IAGDqB,CAAAA,OAAO,CAAGC,qBAAqB,CAAC1C,QAAD,CAAWmB,GAAX,CAAgBC,GAAhB,CAA/B,CAEJ;AACAnB,WAAW,CAACwC,OAAD,CAAX,CACH,CAfD,CAiBA;AACA,GAAMK,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,EAAM,CACxB3C,iBAAiB,CAAC,KAAD,CAAjB,CAEA,GAAI,CAACC,WAAW,EAAIE,SAAhB,GAA8BI,UAAlC,CAA8C,CAC1CqC,eAAe,CAACjC,WAAD,CAAf,CACH,CAEDT,cAAc,CAAC,KAAD,CAAd,CACAE,YAAY,CAAC,KAAD,CAAZ,CACH,CATD,CAWA,GAAMmC,CAAAA,qBAAqB,CAAG,QAAxBA,CAAAA,qBAAwB,CAACM,IAAD,CAAO7B,GAAP,CAAYC,GAAZ,CAAoB,CAC9C,GAAMqB,CAAAA,OAAO,CAAGO,IAAI,CAACC,KAAL,EAAhB,CACA,GAAMC,CAAAA,IAAI,CAAGT,OAAO,CAACtB,GAAD,CAAP,CAAaC,GAAb,CAAb,CACA,GAAM+B,CAAAA,OAAO,gCACND,IADM,MAETvB,MAAM,CAAE,CAACuB,IAAI,CAACvB,MAFL,EAAb,CAIAc,OAAO,CAACtB,GAAD,CAAP,CAAaC,GAAb,EAAoB+B,OAApB,CACA,MAAOV,CAAAA,OAAP,CACH,CATD,CAUA;AACA,GAAMG,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAACI,IAAD,CAAO7B,GAAP,CAAYC,GAAZ,CAAoB,CAEpC,GAAMqB,CAAAA,OAAO,CAAGO,IAAI,CAACC,KAAL,EAAhB,CACA,GAAMG,CAAAA,QAAQ,CAAGX,OAAO,CAACtB,GAAD,CAAP,CAAaC,GAAb,CAAjB,CACA,GAAMiC,CAAAA,SAAS,CAAGZ,OAAO,CAAC9C,sBAAD,CAAP,CAAgCC,sBAAhC,CAAlB,CAEA,GAAM0D,CAAAA,QAAQ,gCACPD,SADO,MAEVhC,OAAO,CAAE,KAFC,CAGVM,MAAM,CAAEX,cAHE,EAAd,CAMAC,iBAAiB,CAACmC,QAAQ,CAACzB,MAAV,CAAjB,CAEA,GAAMwB,CAAAA,OAAO,gCACNC,QADM,MAETzB,MAAM,CAAE,KAFC,CAGTN,OAAO,CAAE,IAHA,EAAb,CAKAoB,OAAO,CAAC9C,sBAAD,CAAP,CAAgCC,sBAAhC,EAA0D0D,QAA1D,CACAb,OAAO,CAACtB,GAAD,CAAP,CAAaC,GAAb,EAAoB+B,OAApB,CACA;AAGA;AAEAxD,sBAAsB,CAAGwB,GAAzB,CACAvB,sBAAsB,CAAGwB,GAAzB,CAEA,MAAOqB,CAAAA,OAAP,CACH,CA9BD,CAgCA,GAAMI,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CAACG,IAAD,CAAO7B,GAAP,CAAYC,GAAZ,CAAoB,CAClC,GAAMqB,CAAAA,OAAO,CAAGO,IAAI,CAACC,KAAL,EAAhB,CACA,GAAMG,CAAAA,QAAQ,CAAGX,OAAO,CAACtB,GAAD,CAAP,CAAaC,GAAb,CAAjB,CACA,GAAMiC,CAAAA,SAAS,CAAGZ,OAAO,CAAC5C,oBAAD,CAAP,CAA8BC,oBAA9B,CAAlB,CACA;AACA,GAAMwD,CAAAA,QAAQ,gCACPD,SADO,MAEV/B,KAAK,CAAE,KAFG,CAGVK,MAAM,CAAEX,cAHE,EAAd,CAKAC,iBAAiB,CAACmC,QAAQ,CAACzB,MAAV,CAAjB,CAEA,GAAMwB,CAAAA,OAAO,gCACNC,QADM,MAETzB,MAAM,CAAE,KAFC,CAGTL,KAAK,CAAE,IAHE,EAAb,CAKAmB,OAAO,CAAC5C,oBAAD,CAAP,CAA8BC,oBAA9B,EAAsDwD,QAAtD,CACAb,OAAO,CAACtB,GAAD,CAAP,CAAaC,GAAb,EAAoB+B,OAApB,CAEA;AAEAtD,oBAAoB,CAAGsB,GAAvB,CACArB,oBAAoB,CAAGsB,GAAvB,CACA,MAAOqB,CAAAA,OAAP,CACH,CAzBD,CA2BA,GAAMc,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,CAACP,IAAD,CAAU,CAC5B;AACA,GAAMP,CAAAA,OAAO,CAAGO,IAAI,CAACC,KAAL,EAAhB,CACA,GAAIC,CAAAA,IAAJ,CACA,IAAK,GAAI/B,CAAAA,GAAG,CAAG,CAAf,CAAkBA,GAAG,CAAGzB,IAAxB,CAA8ByB,GAAG,EAAjC,CAAqC,CACjC,IAAK,GAAIC,CAAAA,GAAG,CAAG,CAAf,CAAkBA,GAAG,CAAGZ,IAAxB,CAA8BY,GAAG,EAAjC,CAAqC,CACjC8B,IAAI,CAAGT,OAAO,CAACtB,GAAD,CAAP,CAAaC,GAAb,CAAP,CACA,GAAM+B,CAAAA,OAAO,gCACND,IADM,MAET3B,QAAQ,CAAEC,QAFD,CAGTC,SAAS,CAAE,KAHF,CAITC,YAAY,CAAE,IAJL,EAAb,CAMAe,OAAO,CAACtB,GAAD,CAAP,CAAaC,GAAb,EAAoB+B,OAApB,CACH,CACJ,CACD,MAAOV,CAAAA,OAAP,CACH,CAjBD,CAmBA,GAAMe,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,EAAM,CACtB,GAAMC,CAAAA,KAAK,CAAGC,QAAQ,CAACC,sBAAT,CAAgC,MAAhC,CAAd,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGH,KAAK,CAACI,MAA1B,CAAkCD,CAAC,EAAnC,CAAuC,CACnCH,KAAK,CAACG,CAAD,CAAL,CAASE,SAAT,CAAmBC,MAAnB,CAA0B,cAA1B,EACAN,KAAK,CAACG,CAAD,CAAL,CAASE,SAAT,CAAmBC,MAAnB,CAA0B,oBAA1B,EACH,CACJ,CAND,CAQA,GAAMC,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,EAAM,CACpB/D,WAAW,CAAC8B,iBAAiB,EAAlB,CAAX,CACAyB,WAAW,GAEd,CAJD,CAKA,GAAMS,CAAAA,mBAAmB,CAAG,QAAtBA,CAAAA,mBAAsB,CAACC,wBAAD,CAA8B,0BAE7CN,CAF6C,EAIlDO,UAAU,CAAC,UAAM,2BACQD,wBAAwB,CAACN,CAAD,CADhC,CACLzC,GADK,uBACLA,GADK,CACAC,GADA,uBACAA,GADA,CAEbsC,QAAQ,CAACU,cAAT,gBAAgCjD,GAAhC,aAAuCC,GAAvC,GAA8C0C,SAA9C,CAAwDO,GAAxD,CAA4D,oBAA5D,EAEH,CAJS,CAIPT,CAAC,CAAG,GAJG,CAAV,CAJkD,EAEtD,IAAK,GAAIA,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGM,wBAAwB,CAACL,MAA7C,CAAqDD,CAAC,EAAtD,CAA0D,OAAjDA,CAAiD,EAOzD,CAEJ,CAXD,CAYA,GAAMU,CAAAA,gBAAgB,CAAG,QAAnBA,CAAAA,gBAAmB,CAACC,mBAAD,CAA+D,IAAzCL,CAAAA,wBAAyC,2DAAdM,SAAc,4BAC3EZ,CAD2E,EAGhFO,UAAU,CAAC,UAAM,CACb,GAAIP,CAAC,GAAKW,mBAAmB,CAACV,MAApB,CAA6B,CAAvC,CAA0C,CACtC,GAAIK,wBAAJ,CACID,mBAAmB,CAACC,wBAAD,CAAnB,CACP,CACJ,CALS,CAKPN,CAAC,CAAG,EALG,CAAV,CAMAO,UAAU,CAAC,UAAM,2BACQI,mBAAmB,CAACX,CAAD,CAD3B,CACLzC,GADK,uBACLA,GADK,CACAC,GADA,uBACAA,GADA,CAEbsC,QAAQ,CAACU,cAAT,gBAAgCjD,GAAhC,aAAuCC,GAAvC,GAA8C0C,SAA9C,CAAwDO,GAAxD,CAA4D,cAA5D,EACH,CAHS,CAGPT,CAAC,CAAG,EAHG,CAAV,CATgF,EACpF,IAAK,GAAIA,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGW,mBAAmB,CAACV,MAAxC,CAAgDD,CAAC,EAAjD,CAAqD,QAA5CA,CAA4C,EAapD,CACD,GAAI,CAACM,wBAAL,CAA+B,CAC3B1E,KAAK,CAACiF,IAAN,CAAW,kBAAX,CAA+B,CAC3BC,QAAQ,CAAE,YADiB,CAA/B,EAGH,CACJ,CApBD,CAqBA;AACA,GAAMC,CAAAA,KAAK,CAAG,QAARA,CAAAA,KAAQ,EAAM,CAChBnB,WAAW,GACXvD,WAAW,CAACsD,aAAa,CAACvD,QAAD,CAAd,CAAX,CACH,CAHD,CAIA;AAEA,GAAM+C,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,CAAC6B,SAAD,CAAe,CACnC,GAAIC,CAAAA,SAAJ,CAAeC,OAAf,CAAwBP,mBAAxB,CAA6CQ,OAA7C,CACA,GAAIH,SAAS,GAAK,UAAlB,CAA8B,CAC1B,GAAIlE,UAAJ,CAAgB,CACZiE,KAAK,GACR,CACDE,SAAS,CAAG7E,QAAQ,CAACL,sBAAD,CAAR,CAAiCC,sBAAjC,CAAZ,CACAkF,OAAO,CAAG9E,QAAQ,CAACH,oBAAD,CAAR,CAA+BC,oBAA/B,CAAV,CAEA;AAP0B,cAQUZ,QAAQ,CAACc,QAAD,CAAW6E,SAAX,CAAsBC,OAAtB,CARlB,CAQvBP,mBARuB,WAQvBA,mBARuB,CAQFQ,OARE,WAQFA,OARE,CAS1BpE,aAAa,CAAC,IAAD,CAAb,CACAI,cAAc,CAAC,UAAD,CAAd,CAEH,CAZD,IAaK,IAAI6D,SAAS,GAAK,OAAlB,CAA2B,CAC5B,GAAIlE,UAAJ,CAAgB,CACZiE,KAAK,GACR,CACDE,SAAS,CAAG7E,QAAQ,CAACL,sBAAD,CAAR,CAAiCC,sBAAjC,CAAZ,CACAkF,OAAO,CAAG9E,QAAQ,CAACH,oBAAD,CAAR,CAA+BC,oBAA/B,CAAV,CAL4B,WAOQX,KAAK,CAACa,QAAD,CAAW6E,SAAX,CAAsBC,OAAtB,CAPb,CAOzBP,mBAPyB,QAOzBA,mBAPyB,CAOJQ,OAPI,QAOJA,OAPI,CAQ5BpE,aAAa,CAAC,IAAD,CAAb,CACAI,cAAc,CAAC,OAAD,CAAd,CAEH,CAXI,IAYA,IAAI6D,SAAS,GAAK,KAAlB,CAAyB,CAC1B,GAAIlE,UAAJ,CAAgB,CACZiE,KAAK,GACR,CACDE,SAAS,CAAG7E,QAAQ,CAACL,sBAAD,CAAR,CAAiCC,sBAAjC,CAAZ,CACAkF,OAAO,CAAG9E,QAAQ,CAACH,oBAAD,CAAR,CAA+BC,oBAA/B,CAAV,CAL0B,SAOUV,GAAG,CAACY,QAAD,CAAW6E,SAAX,CAAsBC,OAAtB,CAPb,CAOvBP,mBAPuB,MAOvBA,mBAPuB,CAOFQ,OAPE,MAOFA,OAPE,CAQ1BpE,aAAa,CAAC,IAAD,CAAb,CACAI,cAAc,CAAC,KAAD,CAAd,CAEH,CAXI,IAaA,IAAI6D,SAAS,GAAK,KAAlB,CAAyB,CAC1B,GAAIlE,UAAJ,CAAgB,CACZiE,KAAK,GACR,CACDE,SAAS,CAAG7E,QAAQ,CAACL,sBAAD,CAAR,CAAiCC,sBAAjC,CAAZ,CACAkF,OAAO,CAAG9E,QAAQ,CAACH,oBAAD,CAAR,CAA+BC,oBAA/B,CAAV,CAL0B,SAOUT,GAAG,CAACW,QAAD,CAAW6E,SAAX,CAAsBC,OAAtB,CAPb,CAOvBP,mBAPuB,MAOvBA,mBAPuB,CAOFQ,OAPE,MAOFA,OAPE,CAQ1BpE,aAAa,CAAC,IAAD,CAAb,CACAI,cAAc,CAAC,KAAD,CAAd,CAEH,CAED;AACA,GAAImD,CAAAA,wBAAJ,CAEA,GAAIa,OAAJ,CAAa,CACTb,wBAAwB,CAAGjF,2BAA2B,CAAC6F,OAAD,CAAtD,CACH,CACDR,gBAAgB,CAACC,mBAAD,CAAsBL,wBAAtB,CAAhB,CACH,CA5DD,CA8DA,mBACI,oBAAC,MAAD,CAAQ,GAAR,EAAY,SAAS,CAAC,YAAtB,CACI,QAAQ,CAAEzE,QADd,CAEI,OAAO,CAAC,QAFZ,CAGI,OAAO,CAAC,SAHZ,CAII,IAAI,CAAC,MAJT,eAMI,2BAAK,SAAS,CAAC,oBAAf,eACI,2BAAK,SAAS,CAAC,eAAf,eACI,8BAAQ,OAAO,CAAE,yBAAMuE,CAAAA,SAAS,EAAf,EAAjB,gBADJ,cAEI,8BAAQ,OAAO,CAAE,yBAAMxE,CAAAA,KAAK,CAACwF,IAAN,CAAW,uBAAX,CAAoC,CACvDN,QAAQ,CAAE,YAD6C,CAEvDO,WAAW,CAAE,KAF0C,CAGvD3C,SAAS,CAAE,IAH4C,CAApC,CAAN,EAAjB,gBAFJ,CADJ,cASI,2BAAK,SAAS,CAAC,mBAAf,eACI,8BAAQ,SAAS,CAAExB,WAAW,GAAK,OAAhB,CAA0B,2BAA1B,CAAwD,IAA3E,CAAiF,OAAO,CAAE,yBAAMiC,CAAAA,eAAe,CAAC,OAAD,CAArB,EAA1F,YADJ,cAEI,8BAAQ,SAAS,CAAEjC,WAAW,GAAK,UAAhB,CAA6B,2BAA7B,CAA2D,IAA9E,CAAoF,OAAO,CAAE,yBAAMiC,CAAAA,eAAe,CAAC,UAAD,CAArB,EAA7F,cAFJ,cAGI,8BAAQ,SAAS,CAAEjC,WAAW,GAAK,KAAhB,CAAwB,2BAAxB,CAAsD,IAAzE,CAA+E,OAAO,CAAE,yBAAMiC,CAAAA,eAAe,CAAC,KAAD,CAArB,EAAxF,QAHJ,cAII,8BAAQ,SAAS,CAAEjC,WAAW,GAAK,KAAhB,CAAwB,2BAAxB,CAAsD,IAAzE,CAA+E,OAAO,CAAE,yBAAMiC,CAAAA,eAAe,CAAC,KAAD,CAArB,EAAxF,QAJJ,CATJ,CANJ,cAsBI,2BAAK,SAAS,CAAC,uBAAf,eAEI,2BAAK,SAAS,CAAC,kBAAf,EAEQ/C,QAAQ,CAACkF,GAAT,CACI,SAAC/D,GAAD,CAAMgE,CAAN,qBAAY,2BAAK,SAAS,CAAC,WAAf,CAA2B,GAAG,CAAEA,CAAhC,EACPhE,GAAG,CAAC+D,GAAJ,CAAQ,SAAChC,IAAD,CAAOU,CAAP,qBACL,oBAAC,IAAD,EAAM,GAAG,CAAEA,CAAX,CAAc,IAAI,CAAEV,IAApB,CACI,aAAa,CAAEJ,aADnB,CAEI,eAAe,CAAEN,eAFrB,CAGI,gBAAgB,CAAEG,gBAHtB,EADK,EAAR,CADO,CAAZ,EADJ,CAFR,CAFJ,cAgBI,2BAAK,SAAS,CAAC,YAAf,eACI,2BAAK,SAAS,CAAC,OAAf,eACI,yBAAG,KAAK,CAAC,iBAAT,EADJ,cAEI,+CAFJ,CADJ,cAKI,2BAAK,SAAS,CAAC,KAAf,eACI,yBAAG,KAAK,CAAC,4BAAT,EADJ,cAEI,6CAFJ,CALJ,cAUI,2BAAK,SAAS,CAAC,MAAf,eACI,2BAAK,SAAS,CAAC,YAAf,EADJ,cAEI,yCAFJ,CAVJ,cAcI,2BAAK,SAAS,CAAC,cAAf,eACI,2BAAK,SAAS,CAAC,YAAf,EADJ,cAEI,kDAFJ,CAdJ,cAkBI,2BAAK,SAAS,CAAC,SAAf,eACI,2BAAK,SAAS,CAAC,eAAf,EADJ,cAEI,iDAFJ,CAlBJ,CAhBJ,CAtBJ,CADJ,CAiEH,CApYD,CAsYA,cAAe5C,CAAAA,UAAf","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport Node from './node/Node';\nimport './pathFinder.css'\nimport { getNodesInShortestPathOrder, dijkstra } from './pathFinder-algos/dijkstra';\nimport { aStar } from './pathFinder-algos/aStar';\nimport { bfs } from './pathFinder-algos/bfs';\nimport { dfs } from './pathFinder-algos/dfs';\nimport { motion } from 'framer-motion'\nimport useWindowSize from '../hooks/windowResize';\nimport { toast } from 'react-toastify';\nimport { variants } from '../framer motion/variants';\n\nvar ROWS = 13;\n// var COLS = 25;\n\nvar CURRENT_START_NODE_ROW = 0;\nvar CURRENT_START_NODE_COL = 8;\nvar CURRENT_END_NODE_ROW = 8;\nvar CURRENT_END_NODE_COL = 0;\n\n\nconst PathFinder = () => {\n\n    const [mainGrid, setMainGrid] = useState([])\n    const [mouseIsPressed, setMouseIsPressed] = useState(false)\n    const [isStartNode, setIsStartNode] = useState(false);\n    const [isEndNode, setIsEndNode] = useState(false);\n    //TODO different cols for different screen\n    const [COLS, SET_COLS] = useState(15);\n    const [alreadyRan, setAlreadyRan] = useState(false); // false if the algo is running first time\n    // else if the algorithm is already ran ; set it true and remove all the node's distance\n    const [notified, setNotified] = useState(false)\n    // const [algoDone, setAlgoDone] = useState(false)\n    const [currentAlgo, setCurrentAlgo] = useState(null)\n\n    const [prevNodeIsWall, setPrevNodeIsWall] = useState(false);\n\n\n\n    const createNode = (row, col) => {\n        return {\n            row,\n            col,\n            isStart: row === CURRENT_START_NODE_ROW && col === CURRENT_START_NODE_COL,\n            isEnd: row === CURRENT_END_NODE_ROW && col === CURRENT_END_NODE_COL,\n            distance: Infinity,\n            isVisited: false,\n            previousNode: null,\n            isWall: false,\n            // for aStar algorithm\n            f: 0,\n            g: 0,\n            h: 0,\n        }\n    }\n\n    const createInitialGrid = () => {\n        let temp_grid = []\n        for (let row = 0; row < ROWS; row++) {\n            var currentRow = []\n            for (let col = 0; col < COLS; col++) {\n                currentRow.push(createNode(row, col))\n            }\n            temp_grid.push(currentRow)\n        }\n        return temp_grid\n    }\n\n    //component did mount\n    useEffect(() => {\n        if (window.innerWidth < 500 && !notified) {\n            toast.warn('Seems like you are using this app in mobile :( Open this app in large screen to get the best experience :)',\n                { autoClose: false })\n        }\n        setNotified(true)\n        setMainGrid(createInitialGrid())\n    }, [COLS, notified])\n    const [width] = useWindowSize()\n    if (width < 500 && COLS !== 15) {\n        SET_COLS(15)\n    }\n    else if (width >= 500 && width <= 1024 && COLS !== 20) {\n        SET_COLS(20)\n    }\n    else if (width > 1024 && COLS !== 25) {\n        SET_COLS(25)\n    }\n\n\n\n    //! MOUSE DOWN -> MOUSE ENTER -> MOUSE UP\n    // MOUSE DOWN : if the node is a start or end node(user wants to set a new start/end node),\n    // then we need to remove* the current start node add the new start node\n    // BUT , if it is neither a start or end node,then convert it to a wall or toggle it\n    const handleMouseDown = (row, col) => {\n        var newGrid;\n        // check if the element to be dragged is a start or end node\n        if (row === CURRENT_START_NODE_ROW && col === CURRENT_START_NODE_COL)\n            setIsStartNode(true); //set the state variable (flag)\n        else if (row === CURRENT_END_NODE_ROW && col === CURRENT_END_NODE_COL)\n            setIsEndNode(true); //set the state variable(flag)\n        else {\n            // else toggle isWall property of that node and update the mainGrid\n            newGrid = getNewGridWallToggled(mainGrid, row, col)\n            setMainGrid(newGrid)\n        }\n        // set mouseIsPressed flag is true;now if user hover over any nodes; that will converted\n        // to a start node or end node or a wall (toggled)\n        setMouseIsPressed(true)\n    }\n\n    const handleMouseEnter = (row, col) => {\n        let newGrid;\n\n        if (!mouseIsPressed) return // return if mousePressed flag is not true (down first)\n\n        if (isStartNode === true) {\n            newGrid = getNewStart(mainGrid, row, col)\n        }\n        else if (isEndNode === true)\n            newGrid = getNewEnd(mainGrid, row, col)\n        else\n            newGrid = getNewGridWallToggled(mainGrid, row, col)\n\n        // update the mainGrid\n        setMainGrid(newGrid)\n    }\n\n    // when leave the mouse , reset the flags to false\n    const handleMouseUp = () => {\n        setMouseIsPressed(false)\n\n        if ((isStartNode || isEndNode) && alreadyRan) {\n            getAnimateArray(currentAlgo)\n        }\n\n        setIsStartNode(false)\n        setIsEndNode(false)\n    }\n\n    const getNewGridWallToggled = (grid, row, col) => {\n        const newGrid = grid.slice()\n        const node = newGrid[row][col]\n        const newNode = {\n            ...node,\n            isWall: !node.isWall\n        }\n        newGrid[row][col] = newNode\n        return newGrid\n    }\n    // toggle the start when dragged\n    const getNewStart = (grid, row, col) => {\n\n        const newGrid = grid.slice()\n        const new_node = newGrid[row][col]\n        const prev_node = newGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL]\n\n        const prevNode = {\n            ...prev_node,\n            isStart: false,\n            isWall: prevNodeIsWall\n        }\n\n        setPrevNodeIsWall(new_node.isWall)\n\n        const newNode = {\n            ...new_node,\n            isWall: false,\n            isStart: true,\n        }\n        newGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL] = prevNode;\n        newGrid[row][col] = newNode\n        //  console.log(newGrid);\n\n\n        // update previous variables with current row and current col\n\n        CURRENT_START_NODE_ROW = row\n        CURRENT_START_NODE_COL = col\n\n        return newGrid\n    }\n\n    const getNewEnd = (grid, row, col) => {\n        const newGrid = grid.slice()\n        const new_node = newGrid[row][col]\n        const prev_node = newGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL]\n        //previous node\n        const prevNode = {\n            ...prev_node,\n            isEnd: false,\n            isWall: prevNodeIsWall\n        }\n        setPrevNodeIsWall(new_node.isWall)\n\n        const newNode = {\n            ...new_node,\n            isWall: false,\n            isEnd: true,\n        }\n        newGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL] = prevNode;\n        newGrid[row][col] = newNode\n\n        // update previous variables with current row and current col\n\n        CURRENT_END_NODE_ROW = row\n        CURRENT_END_NODE_COL = col\n        return newGrid\n    }\n\n    const reArrangeGrid = (grid) => {\n        // make sure don't reset the walls\n        const newGrid = grid.slice()\n        let node;\n        for (let row = 0; row < ROWS; row++) {\n            for (let col = 0; col < COLS; col++) {\n                node = newGrid[row][col]\n                const newNode = {\n                    ...node,\n                    distance: Infinity,\n                    isVisited: false,\n                    previousNode: null\n                }\n                newGrid[row][col] = newNode\n            }\n        }\n        return newGrid\n    }\n\n    const resetColors = () => {\n        const nodes = document.getElementsByClassName(\"node\");\n        for (let i = 0; i < nodes.length; i++) {\n            nodes[i].classList.remove(\"node-visited\")\n            nodes[i].classList.remove(\"node-shortest-path\")\n        }\n    }\n\n    const resetGrid = () => {\n        setMainGrid(createInitialGrid())\n        resetColors()\n\n    }\n    const animateShortestPath = (nodesInShortestPathOrder) => {\n\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n\n            setTimeout(() => {\n                const { row, col } = nodesInShortestPathOrder[i]\n                document.getElementById(`node-${row}-${col}`).classList.add('node-shortest-path')\n\n            }, i * 100)\n        }\n\n    }\n    const animateTraversal = (visitedNodesInOrder, nodesInShortestPathOrder = undefined) => {\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\n\n            setTimeout(() => {\n                if (i === visitedNodesInOrder.length - 1) {\n                    if (nodesInShortestPathOrder)\n                        animateShortestPath(nodesInShortestPathOrder)\n                }\n            }, i * 20)\n            setTimeout(() => {\n                const { row, col } = visitedNodesInOrder[i]\n                document.getElementById(`node-${row}-${col}`).classList.add('node-visited')\n            }, i * 20)\n\n        }\n        if (!nodesInShortestPathOrder) {\n            toast.info('No path found 🐹', {\n                position: 'top-center'\n            })\n        }\n    }\n    //TODO Re Re Re Re Re ................... rename the functions :(\n    const reRun = () => {\n        resetColors();\n        setMainGrid(reArrangeGrid(mainGrid));\n    }\n    //TODO notify when path is not found \n\n    const getAnimateArray = (algorithm) => {\n        var startNode, endNode, visitedNodesInOrder, success;\n        if (algorithm === 'dijkstra') {\n            if (alreadyRan) {\n                reRun()\n            }\n            startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL]\n            endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];\n\n            // object destructuring and store in already defined variables\n            ({ visitedNodesInOrder, success } = dijkstra(mainGrid, startNode, endNode))\n            setAlreadyRan(true);\n            setCurrentAlgo('dijkstra')\n\n        }\n        else if (algorithm === 'aStar') {\n            if (alreadyRan) {\n                reRun()\n            }\n            startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL]\n            endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];\n\n            ({ visitedNodesInOrder, success } = aStar(mainGrid, startNode, endNode))\n            setAlreadyRan(true);\n            setCurrentAlgo('aStar')\n\n        }\n        else if (algorithm === 'BFS') {\n            if (alreadyRan) {\n                reRun()\n            }\n            startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL]\n            endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];\n\n            ({ visitedNodesInOrder, success } = bfs(mainGrid, startNode, endNode))\n            setAlreadyRan(true);\n            setCurrentAlgo('BFS')\n\n        }\n\n        else if (algorithm === 'DFS') {\n            if (alreadyRan) {\n                reRun()\n            }\n            startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL]\n            endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];\n\n            ({ visitedNodesInOrder, success } = dfs(mainGrid, startNode, endNode))\n            setAlreadyRan(true);\n            setCurrentAlgo('DFS')\n\n        }\n\n        //console.log(visitedNodesInOrder, success);\n        var nodesInShortestPathOrder;\n\n        if (success) {\n            nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode)\n        }\n        animateTraversal(visitedNodesInOrder, nodesInShortestPathOrder)\n    }\n\n    return (\n        <motion.div className=\"pathFinder\"\n            variants={variants}\n            initial=\"hidden\"\n            animate=\"visible\"\n            exit=\"exit\"\n        >\n            <div className=\"pathFinder__navbar\">\n                <div className=\"util__buttons\">\n                    <button onClick={() => resetGrid()}>Clear Board</button>\n                    <button onClick={() => toast.dark('⛔ Not implemented yet', {\n                        position: 'top-center',\n                        closeButton: false,\n                        autoClose: 3000\n                    })}>Start Timer</button>\n                </div>\n                <div className=\"pathFinder__types\">\n                    <button className={currentAlgo === 'aStar' ? 'pathFinder__button-active' : null} onClick={() => getAnimateArray('aStar')}> A-star</button>\n                    <button className={currentAlgo === 'dijkstra' ? 'pathFinder__button-active' : null} onClick={() => getAnimateArray('dijkstra')}>Dijkstra </button>\n                    <button className={currentAlgo === 'DFS' ? 'pathFinder__button-active' : null} onClick={() => getAnimateArray('DFS')}>DFS</button>\n                    <button className={currentAlgo === 'BFS' ? 'pathFinder__button-active' : null} onClick={() => getAnimateArray('BFS')}>BFS</button>\n                </div>\n            </div>\n            <div className=\"pathFinder__container\">\n\n                <div className=\"pathFinder__grid\">\n                    {\n                        mainGrid.map(\n                            (row, j) => <div className=\"grid__row\" key={j}>\n                                {row.map((node, i) =>\n                                    <Node key={i} node={node}\n                                        handleMouseUp={handleMouseUp}\n                                        handleMouseDown={handleMouseDown}\n                                        handleMouseEnter={handleMouseEnter} />\n                                )}\n                            </div>\n                        )\n                    }\n                </div>\n                <div className=\"indicators\">\n                    <div className=\"start\">\n                        <i class=\"fas fa-car mr-2\"></i>\n                        <strong>Start Node</strong>\n                    </div>\n                    <div className=\"end\">\n                        <i class=\"fas fa-flag-checkered mr-2\"></i>\n                        <strong>End Node</strong>\n                    </div>\n\n                    <div className=\"wall\">\n                        <div className=\"wall__icon\"></div>\n                        <strong>Wall</strong>\n                    </div>\n                    <div className=\"shortestPath\">\n                        <div className=\"path__icon\"></div>\n                        <strong>Shortest Path</strong>\n                    </div>\n                    <div className=\"visited\">\n                        <div className=\"visited__icon\"></div>\n                        <strong>Visited Node</strong>\n                    </div>\n                </div>\n            </div>\n        </motion.div>\n    );\n};\n\nexport default PathFinder;"]},"metadata":{},"sourceType":"module"}