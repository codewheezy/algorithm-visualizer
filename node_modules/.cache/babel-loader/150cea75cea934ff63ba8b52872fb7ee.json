{"ast":null,"code":"import { getUnvisitedNeighbors } from \"./util_functions\";\nexport const bfs = (grid, startNode, endNode) => {\n  // create visitedNodesInOrder array to keep track and animate\n  const visitedNodesInOrder = [];\n  var queue = [];\n  queue.push(startNode);\n\n  while (queue.length > 0) {\n    const current = queue.shift();\n    current.isVisited = true;\n    visitedNodesInOrder.push(current);\n\n    if (current.row === endNode.row && current.col === endNode.col) {\n      console.log(\"done\");\n      return {\n        visitedNodesInOrder,\n        success: true\n      };\n    }\n\n    updateUnvisitedNeighbors(current, grid, queue);\n  } //TODO return success:false(if not found)\n\n\n  console.log(\"path not found\");\n};\n\nconst updateUnvisitedNeighbors = (node, grid, queue) => {\n  // get unvisited neighbors\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (const neighbor of unvisitedNeighbors) {\n    // set neighbor's prev node  = current node\n    neighbor.previousNode = node; //add it to the queue\n\n    if (!queue.includes(neighbor)) queue.push(neighbor);\n  }\n};","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/path-finder/pathFinder-algos/bfs.js"],"names":["getUnvisitedNeighbors","bfs","grid","startNode","endNode","visitedNodesInOrder","queue","push","length","current","shift","isVisited","row","col","console","log","success","updateUnvisitedNeighbors","node","unvisitedNeighbors","neighbor","previousNode","includes"],"mappings":"AAAA,SAASA,qBAAT,QAAsC,kBAAtC;AAEA,OAAO,MAAMC,GAAG,GAAG,CAACC,IAAD,EAAOC,SAAP,EAAkBC,OAAlB,KAA8B;AAC7C;AACA,QAAMC,mBAAmB,GAAG,EAA5B;AACA,MAAIC,KAAK,GAAG,EAAZ;AACAA,EAAAA,KAAK,CAACC,IAAN,CAAWJ,SAAX;;AAEA,SAAOG,KAAK,CAACE,MAAN,GAAe,CAAtB,EAAyB;AACrB,UAAMC,OAAO,GAAGH,KAAK,CAACI,KAAN,EAAhB;AACAD,IAAAA,OAAO,CAACE,SAAR,GAAoB,IAApB;AACAN,IAAAA,mBAAmB,CAACE,IAApB,CAAyBE,OAAzB;;AACA,QAAIA,OAAO,CAACG,GAAR,KAAgBR,OAAO,CAACQ,GAAxB,IAA+BH,OAAO,CAACI,GAAR,KAAgBT,OAAO,CAACS,GAA3D,EAAgE;AAC5DC,MAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ;AACA,aAAO;AAAEV,QAAAA,mBAAF;AAAuBW,QAAAA,OAAO,EAAE;AAAhC,OAAP;AACH;;AACDC,IAAAA,wBAAwB,CAACR,OAAD,EAAUP,IAAV,EAAgBI,KAAhB,CAAxB;AACH,GAf4C,CAgB7C;;;AACAQ,EAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ;AACH,CAlBM;;AAoBP,MAAME,wBAAwB,GAAG,CAACC,IAAD,EAAOhB,IAAP,EAAaI,KAAb,KAAuB;AACpD;AACA,QAAMa,kBAAkB,GAAGnB,qBAAqB,CAACkB,IAAD,EAAOhB,IAAP,CAAhD;;AACA,OAAK,MAAMkB,QAAX,IAAuBD,kBAAvB,EAA2C;AACvC;AACAC,IAAAA,QAAQ,CAACC,YAAT,GAAwBH,IAAxB,CAFuC,CAGvC;;AACA,QAAI,CAACZ,KAAK,CAACgB,QAAN,CAAeF,QAAf,CAAL,EACId,KAAK,CAACC,IAAN,CAAWa,QAAX;AACP;AACJ,CAVD","sourcesContent":["import { getUnvisitedNeighbors } from \"./util_functions\";\n\nexport const bfs = (grid, startNode, endNode) => {\n    // create visitedNodesInOrder array to keep track and animate\n    const visitedNodesInOrder = []\n    var queue = []\n    queue.push(startNode)\n\n    while (queue.length > 0) {\n        const current = queue.shift();\n        current.isVisited = true\n        visitedNodesInOrder.push(current)\n        if (current.row === endNode.row && current.col === endNode.col) {\n            console.log(\"done\");\n            return { visitedNodesInOrder, success: true }\n        }\n        updateUnvisitedNeighbors(current, grid, queue)\n    }\n    //TODO return success:false(if not found)\n    console.log(\"path not found\");\n}\n\nconst updateUnvisitedNeighbors = (node, grid, queue) => {\n    // get unvisited neighbors\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid)\n    for (const neighbor of unvisitedNeighbors) {\n        // set neighbor's prev node  = current node\n        neighbor.previousNode = node\n        //add it to the queue\n        if (!queue.includes(neighbor))\n            queue.push(neighbor)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}