{"ast":null,"code":"export const dijkstra = (grid, startNode, endNode) => {\n  if (startNode === endNode) return false; // create visitedNodesInOrder array to keep track and animate\n\n  const visitedNodesInOrder = []; // get all the unvisited nodes\n\n  var unvisitedNodes = getAllNodes(grid); // set startNode distance 0\n\n  startNode.distance = 0; //TODO\n\n  while (unvisitedNodes.length) {\n    // sort unvisited ascending order and get the first value(shift())\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.distance === Infinity) return {\n      visitedNodesInOrder,\n      success: false\n    }; // set closest node as visited and push it to visited nodes in order\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === endNode) return {\n      visitedNodesInOrder,\n      success: true\n    }; // update unvisited neighbors\n\n    updateUnvisitedNeighbors(closestNode, grid);\n  } //TODO do something when failed :(\n\n\n  console.log(\"Failed :(\");\n};\n\nconst getAllNodes = grid => {\n  const nodes = [];\n\n  for (let row of grid) for (let n of row) nodes.push(n);\n\n  return nodes;\n};\n\nconst sortNodesByDistance = unvisitedNodes => {\n  unvisitedNodes.sort((nodeA, nodeB) => {\n    return nodeA.distance - nodeB.distance;\n  });\n};\n\nconst updateUnvisitedNeighbors = (node, grid) => {\n  // get unvisited neighbors\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (const neighbor of unvisitedNeighbors) {\n    // increment every neighbor's distance by 1\n    neighbor.distance = node.distance + 1; // set neighbor's prev node  = current node\n\n    neighbor.previousNode = node;\n  }\n};\n\nconst getUnvisitedNeighbors = (node, grid) => {\n  const neighbors = [];\n  const {\n    row,\n    col\n  } = node;\n  if (row > 0 && !grid[row - 1][col].isWall) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1 && !grid[row + 1][col].isWall) neighbors.push(grid[row + 1][col]);\n  if (col > 0 && !grid[row][col - 1].isWall) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1 && !grid[row][col + 1].isWall) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nexport const getNodesInShortestPathOrder = endNode => {\n  let nodesInShortestPathOrder = [];\n  let currentNode = endNode;\n\n  while (currentNode) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  } // console.log(nodesInShortestPathOrder);\n\n\n  return nodesInShortestPathOrder;\n};","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/path-finder/pathFinder-algos/dijkstra.js"],"names":["dijkstra","grid","startNode","endNode","visitedNodesInOrder","unvisitedNodes","getAllNodes","distance","length","sortNodesByDistance","closestNode","shift","Infinity","success","isVisited","push","updateUnvisitedNeighbors","console","log","nodes","row","n","sort","nodeA","nodeB","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","isWall","filter","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"AAAA,OAAO,MAAMA,QAAQ,GAAG,CAACC,IAAD,EAAOC,SAAP,EAAkBC,OAAlB,KAA8B;AAClD,MAAID,SAAS,KAAKC,OAAlB,EACI,OAAO,KAAP,CAF8C,CAIlD;;AACA,QAAMC,mBAAmB,GAAG,EAA5B,CALkD,CAOlD;;AACA,MAAIC,cAAc,GAAGC,WAAW,CAACL,IAAD,CAAhC,CARkD,CASlD;;AACAC,EAAAA,SAAS,CAACK,QAAV,GAAqB,CAArB,CAVkD,CAWlD;;AAEA,SAAOF,cAAc,CAACG,MAAtB,EAA8B;AAC1B;AACAC,IAAAA,mBAAmB,CAACJ,cAAD,CAAnB;AACA,UAAMK,WAAW,GAAGL,cAAc,CAACM,KAAf,EAApB;AAEA,QAAID,WAAW,CAACH,QAAZ,KAAyBK,QAA7B,EACI,OAAO;AAAER,MAAAA,mBAAF;AAAuBS,MAAAA,OAAO,EAAE;AAAhC,KAAP,CANsB,CAQ1B;;AACAH,IAAAA,WAAW,CAACI,SAAZ,GAAwB,IAAxB;AACAV,IAAAA,mBAAmB,CAACW,IAApB,CAAyBL,WAAzB;AAEA,QAAIA,WAAW,KAAKP,OAApB,EACI,OAAO;AAAEC,MAAAA,mBAAF;AAAuBS,MAAAA,OAAO,EAAE;AAAhC,KAAP,CAbsB,CAe1B;;AACAG,IAAAA,wBAAwB,CAACN,WAAD,EAAcT,IAAd,CAAxB;AACH,GA9BiD,CA+BlD;;;AACAgB,EAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AACH,CAjCM;;AAmCP,MAAMZ,WAAW,GAAIL,IAAD,IAAU;AAC1B,QAAMkB,KAAK,GAAG,EAAd;;AACA,OAAK,IAAIC,GAAT,IAAgBnB,IAAhB,EACI,KAAK,IAAIoB,CAAT,IAAcD,GAAd,EACID,KAAK,CAACJ,IAAN,CAAWM,CAAX;;AACR,SAAOF,KAAP;AACH,CAND;;AAQA,MAAMV,mBAAmB,GAAIJ,cAAD,IAAoB;AAE5CA,EAAAA,cAAc,CAACiB,IAAf,CAAoB,CAACC,KAAD,EAAQC,KAAR,KAAkB;AAClC,WAAOD,KAAK,CAAChB,QAAN,GAAiBiB,KAAK,CAACjB,QAA9B;AACH,GAFD;AAGH,CALD;;AAMA,MAAMS,wBAAwB,GAAG,CAACS,IAAD,EAAOxB,IAAP,KAAgB;AAC7C;AACA,QAAMyB,kBAAkB,GAAGC,qBAAqB,CAACF,IAAD,EAAOxB,IAAP,CAAhD;;AACA,OAAK,MAAM2B,QAAX,IAAuBF,kBAAvB,EAA2C;AACvC;AACAE,IAAAA,QAAQ,CAACrB,QAAT,GAAoBkB,IAAI,CAAClB,QAAL,GAAgB,CAApC,CAFuC,CAGvC;;AACAqB,IAAAA,QAAQ,CAACC,YAAT,GAAwBJ,IAAxB;AACH;AACJ,CATD;;AAWA,MAAME,qBAAqB,GAAG,CAACF,IAAD,EAAOxB,IAAP,KAAgB;AAC1C,QAAM6B,SAAS,GAAG,EAAlB;AACA,QAAM;AAAEV,IAAAA,GAAF;AAAOW,IAAAA;AAAP,MAAeN,IAArB;AACA,MAAIL,GAAG,GAAG,CAAN,IAAW,CAACnB,IAAI,CAACmB,GAAG,GAAG,CAAP,CAAJ,CAAcW,GAAd,EAAmBC,MAAnC,EAA2CF,SAAS,CAACf,IAAV,CAAed,IAAI,CAACmB,GAAG,GAAG,CAAP,CAAJ,CAAcW,GAAd,CAAf;AAC3C,MAAIX,GAAG,GAAGnB,IAAI,CAACO,MAAL,GAAc,CAApB,IAAyB,CAACP,IAAI,CAACmB,GAAG,GAAG,CAAP,CAAJ,CAAcW,GAAd,EAAmBC,MAAjD,EAAyDF,SAAS,CAACf,IAAV,CAAed,IAAI,CAACmB,GAAG,GAAG,CAAP,CAAJ,CAAcW,GAAd,CAAf;AACzD,MAAIA,GAAG,GAAG,CAAN,IAAW,CAAC9B,IAAI,CAACmB,GAAD,CAAJ,CAAUW,GAAG,GAAG,CAAhB,EAAmBC,MAAnC,EAA2CF,SAAS,CAACf,IAAV,CAAed,IAAI,CAACmB,GAAD,CAAJ,CAAUW,GAAG,GAAG,CAAhB,CAAf;AAC3C,MAAIA,GAAG,GAAG9B,IAAI,CAAC,CAAD,CAAJ,CAAQO,MAAR,GAAiB,CAAvB,IAA4B,CAACP,IAAI,CAACmB,GAAD,CAAJ,CAAUW,GAAG,GAAG,CAAhB,EAAmBC,MAApD,EAA4DF,SAAS,CAACf,IAAV,CAAed,IAAI,CAACmB,GAAD,CAAJ,CAAUW,GAAG,GAAG,CAAhB,CAAf;AAC5D,SAAOD,SAAS,CAACG,MAAV,CAAiBL,QAAQ,IAAI,CAACA,QAAQ,CAACd,SAAvC,CAAP;AACH,CARD;;AAUA,OAAO,MAAMoB,2BAA2B,GAAI/B,OAAD,IAAa;AACpD,MAAIgC,wBAAwB,GAAG,EAA/B;AACA,MAAIC,WAAW,GAAGjC,OAAlB;;AACA,SAAOiC,WAAP,EAAoB;AAChBD,IAAAA,wBAAwB,CAACE,OAAzB,CAAiCD,WAAjC;AACAA,IAAAA,WAAW,GAAGA,WAAW,CAACP,YAA1B;AACH,GANmD,CAOpD;;;AACA,SAAOM,wBAAP;AACH,CATM","sourcesContent":["export const dijkstra = (grid, startNode, endNode) => {\n    if (startNode === endNode)\n        return false\n\n    // create visitedNodesInOrder array to keep track and animate\n    const visitedNodesInOrder = []\n\n    // get all the unvisited nodes\n    var unvisitedNodes = getAllNodes(grid)\n    // set startNode distance 0\n    startNode.distance = 0\n    //TODO\n\n    while (unvisitedNodes.length) {\n        // sort unvisited ascending order and get the first value(shift())\n        sortNodesByDistance(unvisitedNodes)\n        const closestNode = unvisitedNodes.shift();\n\n        if (closestNode.distance === Infinity)\n            return { visitedNodesInOrder, success: false }\n\n        // set closest node as visited and push it to visited nodes in order\n        closestNode.isVisited = true\n        visitedNodesInOrder.push(closestNode)\n\n        if (closestNode === endNode)\n            return { visitedNodesInOrder, success: true }\n\n        // update unvisited neighbors\n        updateUnvisitedNeighbors(closestNode, grid)\n    }\n    //TODO do something when failed :(\n    console.log(\"Failed :(\");\n}\n\nconst getAllNodes = (grid) => {\n    const nodes = []\n    for (let row of grid)\n        for (let n of row)\n            nodes.push(n)\n    return nodes\n}\n\nconst sortNodesByDistance = (unvisitedNodes) => {\n\n    unvisitedNodes.sort((nodeA, nodeB) => {\n        return nodeA.distance - nodeB.distance\n    })\n}\nconst updateUnvisitedNeighbors = (node, grid) => {\n    // get unvisited neighbors\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid)\n    for (const neighbor of unvisitedNeighbors) {\n        // increment every neighbor's distance by 1\n        neighbor.distance = node.distance + 1\n        // set neighbor's prev node  = current node\n        neighbor.previousNode = node\n    }\n}\n\nconst getUnvisitedNeighbors = (node, grid) => {\n    const neighbors = []\n    const { row, col } = node\n    if (row > 0 && !grid[row - 1][col].isWall) neighbors.push(grid[row - 1][col])\n    if (row < grid.length - 1 && !grid[row + 1][col].isWall) neighbors.push(grid[row + 1][col])\n    if (col > 0 && !grid[row][col - 1].isWall) neighbors.push(grid[row][col - 1])\n    if (col < grid[0].length - 1 && !grid[row][col + 1].isWall) neighbors.push(grid[row][col + 1])\n    return neighbors.filter(neighbor => !neighbor.isVisited)\n}\n\nexport const getNodesInShortestPathOrder = (endNode) => {\n    let nodesInShortestPathOrder = []\n    let currentNode = endNode\n    while (currentNode) {\n        nodesInShortestPathOrder.unshift(currentNode)\n        currentNode = currentNode.previousNode\n    }\n    // console.log(nodesInShortestPathOrder);\n    return nodesInShortestPathOrder\n}"]},"metadata":{},"sourceType":"module"}