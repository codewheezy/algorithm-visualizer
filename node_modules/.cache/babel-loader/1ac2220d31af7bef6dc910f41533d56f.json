{"ast":null,"code":"var _jsxFileName = \"/Users/uchennaibe/Desktop/algorithm-visualizer/src/path-finder/PathFinder.js\";\nimport React, { useEffect, useState } from 'react';\nimport Node from './node/Node';\nimport './pathFinder.css';\nimport { getNodesInShortestPathOrder, dijkstra } from './pathFinder-algos/dijkstra';\nimport { aStar } from './pathFinder-algos/aStar';\nimport { bfs } from './pathFinder-algos/bfs';\nimport { dfs } from './pathFinder-algos/dfs';\nimport { motion } from 'framer-motion';\nimport useWindowSize from '../hooks/windowResize';\nimport { toast } from 'react-toastify';\nimport { variants } from '../framer motion/variants';\nvar ROWS = 13; // var COLS = 25;\n\nvar CURRENT_START_NODE_ROW = 0;\nvar CURRENT_START_NODE_COL = 8;\nvar CURRENT_END_NODE_ROW = 8;\nvar CURRENT_END_NODE_COL = 0;\n\nconst PathFinder = () => {\n  const [mainGrid, setMainGrid] = useState([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [isStartNode, setIsStartNode] = useState(false);\n  const [isEndNode, setIsEndNode] = useState(false); //TODO different cols for different screen\n\n  const [COLS, SET_COLS] = useState(15);\n  const [alreadyRan, setAlreadyRan] = useState(false); // false if the algo is running first time\n  // else if the algorithm is already ran ; set it true and remove all the node's distance\n\n  const [notified, setNotified] = useState(false); // const [algoDone, setAlgoDone] = useState(false)\n\n  const [currentAlgo, setCurrentAlgo] = useState(null);\n  const [prevNodeIsWall, setPrevNodeIsWall] = useState(false);\n\n  const createNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart: row === CURRENT_START_NODE_ROW && col === CURRENT_START_NODE_COL,\n      isEnd: row === CURRENT_END_NODE_ROW && col === CURRENT_END_NODE_COL,\n      distance: Infinity,\n      isVisited: false,\n      previousNode: null,\n      isWall: false,\n      // for aStar algorithm\n      f: 0,\n      g: 0,\n      h: 0\n    };\n  };\n\n  const createInitialGrid = () => {\n    let temp_grid = [];\n\n    for (let row = 0; row < ROWS; row++) {\n      var currentRow = [];\n\n      for (let col = 0; col < COLS; col++) {\n        currentRow.push(createNode(row, col));\n      }\n\n      temp_grid.push(currentRow);\n    }\n\n    return temp_grid;\n  }; //component did mount\n\n\n  useEffect(() => {\n    if (window.innerWidth < 500 && !notified) {\n      toast.warn('Seems like you are using this app in mobile :( Open this app in large screen to get the best experience :)', {\n        autoClose: false\n      });\n    }\n\n    setNotified(true);\n    setMainGrid(createInitialGrid());\n  }, [COLS]);\n  const [width] = useWindowSize();\n\n  if (width < 500 && COLS !== 15) {\n    SET_COLS(15);\n  } else if (width >= 500 && width <= 1024 && COLS !== 20) {\n    SET_COLS(20);\n  } else if (width > 1024 && COLS !== 25) {\n    SET_COLS(25);\n  } //! MOUSE DOWN -> MOUSE ENTER -> MOUSE UP\n  // MOUSE DOWN : if the node is a start or end node(user wants to set a new start/end node),\n  // then we need to remove* the current start node add the new start node\n  // BUT , if it is neither a start or end node,then convert it to a wall or toggle it\n\n\n  const handleMouseDown = (row, col) => {\n    var newGrid; // check if the element to be dragged is a start or end node\n\n    if (row === CURRENT_START_NODE_ROW && col === CURRENT_START_NODE_COL) setIsStartNode(true); //set the state variable (flag)\n    else if (row === CURRENT_END_NODE_ROW && col === CURRENT_END_NODE_COL) setIsEndNode(true); //set the state variable(flag)\n    else {\n      // else toggle isWall property of that node and update the mainGrid\n      newGrid = getNewGridWallToggled(mainGrid, row, col);\n      setMainGrid(newGrid);\n    } // set mouseIsPressed flag is true;now if user hover over any nodes; that will converted\n    // to a start node or end node or a wall (toggled)\n\n    setMouseIsPressed(true);\n  };\n\n  const handleMouseEnter = (row, col) => {\n    let newGrid;\n    if (!mouseIsPressed) return; // return if mousePressed flag is not true (down first)\n\n    if (isStartNode === true) {\n      newGrid = getNewStart(mainGrid, row, col);\n    } else if (isEndNode === true) newGrid = getNewEnd(mainGrid, row, col);else newGrid = getNewGridWallToggled(mainGrid, row, col); // update the mainGrid\n\n\n    setMainGrid(newGrid);\n  }; // when leave the mouse , reset the flags to false\n\n\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n\n    if ((isStartNode || isEndNode) && alreadyRan) {\n      getAnimateArray(currentAlgo);\n    }\n\n    setIsStartNode(false);\n    setIsEndNode(false);\n  };\n\n  const getNewGridWallToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = { ...node,\n      isWall: !node.isWall\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  }; // toggle the start when dragged\n\n\n  const getNewStart = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const new_node = newGrid[row][col];\n    const prev_node = newGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL];\n    const prevNode = { ...prev_node,\n      isStart: false,\n      isWall: prevNodeIsWall\n    };\n    setPrevNodeIsWall(new_node.isWall);\n    const newNode = { ...new_node,\n      isWall: false,\n      isStart: true\n    };\n    newGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL] = prevNode;\n    newGrid[row][col] = newNode; //  console.log(newGrid);\n    // update previous variables with current row and current col\n\n    CURRENT_START_NODE_ROW = row;\n    CURRENT_START_NODE_COL = col;\n    return newGrid;\n  };\n\n  const getNewEnd = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const new_node = newGrid[row][col];\n    const prev_node = newGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL]; //previous node\n\n    const prevNode = { ...prev_node,\n      isEnd: false,\n      isWall: prevNodeIsWall\n    };\n    setPrevNodeIsWall(new_node.isWall);\n    const newNode = { ...new_node,\n      isWall: false,\n      isEnd: true\n    };\n    newGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL] = prevNode;\n    newGrid[row][col] = newNode; // update previous variables with current row and current col\n\n    CURRENT_END_NODE_ROW = row;\n    CURRENT_END_NODE_COL = col;\n    return newGrid;\n  };\n\n  const reArrangeGrid = grid => {\n    // make sure don't reset the walls\n    const newGrid = grid.slice();\n    let node;\n\n    for (let row = 0; row < ROWS; row++) {\n      for (let col = 0; col < COLS; col++) {\n        node = newGrid[row][col];\n        const newNode = { ...node,\n          distance: Infinity,\n          isVisited: false,\n          previousNode: null\n        };\n        newGrid[row][col] = newNode;\n      }\n    }\n\n    return newGrid;\n  };\n\n  const resetColors = () => {\n    const nodes = document.getElementsByClassName(\"node\");\n\n    for (let i = 0; i < nodes.length; i++) {\n      nodes[i].classList.remove(\"node-visited\");\n      nodes[i].classList.remove(\"node-shortest-path\");\n    }\n  };\n\n  const resetGrid = () => {\n    setMainGrid(createInitialGrid());\n    resetColors();\n  };\n\n  const animateShortestPath = nodesInShortestPathOrder => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const {\n          row,\n          col\n        } = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${row}-${col}`).classList.add('node-shortest-path');\n      }, i * 100);\n    }\n  };\n\n  const animateTraversal = function (visitedNodesInOrder) {\n    let nodesInShortestPathOrder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\n      setTimeout(() => {\n        if (i === visitedNodesInOrder.length - 1) {\n          if (nodesInShortestPathOrder) animateShortestPath(nodesInShortestPathOrder);\n        }\n      }, i * 20);\n      setTimeout(() => {\n        const {\n          row,\n          col\n        } = visitedNodesInOrder[i];\n        document.getElementById(`node-${row}-${col}`).classList.add('node-visited');\n      }, i * 20);\n    }\n\n    if (!nodesInShortestPathOrder) {\n      toast.info('No path found ðŸ¹', {\n        position: 'top-center'\n      });\n    }\n  }; //TODO Re Re Re Re Re ................... rename the functions :(\n\n\n  const reRun = () => {\n    resetColors();\n    setMainGrid(reArrangeGrid(mainGrid));\n  }; //TODO notify when path is not found \n\n\n  const getAnimateArray = algorithm => {\n    var startNode, endNode, visitedNodesInOrder, success;\n\n    if (algorithm === 'dijkstra') {\n      if (alreadyRan) {\n        reRun();\n      }\n\n      startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL];\n      endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL]; // object destructuring and store in already defined variables\n\n      ({\n        visitedNodesInOrder,\n        success\n      } = dijkstra(mainGrid, startNode, endNode));\n      setAlreadyRan(true);\n      setCurrentAlgo('dijkstra');\n    } else if (algorithm === 'aStar') {\n      if (alreadyRan) {\n        reRun();\n      }\n\n      startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL];\n      endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];\n      ({\n        visitedNodesInOrder,\n        success\n      } = aStar(mainGrid, startNode, endNode));\n      setAlreadyRan(true);\n      setCurrentAlgo('aStar');\n    } else if (algorithm === 'BFS') {\n      if (alreadyRan) {\n        reRun();\n      }\n\n      startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL];\n      endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];\n      ({\n        visitedNodesInOrder,\n        success\n      } = bfs(mainGrid, startNode, endNode));\n      setAlreadyRan(true);\n      setCurrentAlgo('BFS');\n    } else if (algorithm === 'DFS') {\n      if (alreadyRan) {\n        reRun();\n      }\n\n      startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL];\n      endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];\n      ({\n        visitedNodesInOrder,\n        success\n      } = dfs(mainGrid, startNode, endNode));\n      setAlreadyRan(true);\n      setCurrentAlgo('DFS');\n    } //console.log(visitedNodesInOrder, success);\n\n\n    var nodesInShortestPathOrder;\n\n    if (success) {\n      nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode);\n    }\n\n    animateTraversal(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  return /*#__PURE__*/React.createElement(motion.div, {\n    className: \"pathFinder\",\n    variants: variants,\n    initial: \"hidden\",\n    animate: \"visible\",\n    exit: \"exit\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 346,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"pathFinder__navbar\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 352,\n      columnNumber: 13\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"util__buttons\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 353,\n      columnNumber: 17\n    }\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => resetGrid(),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 354,\n      columnNumber: 21\n    }\n  }, \"Clear Board\"), /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => toast.dark('â›” Not implemented yet', {\n      position: 'top-center',\n      closeButton: false,\n      autoClose: 3000\n    }),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 355,\n      columnNumber: 21\n    }\n  }, \"Start Timer\")), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"pathFinder__types\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 361,\n      columnNumber: 17\n    }\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    className: currentAlgo === 'aStar' ? 'pathFinder__button-active' : null,\n    onClick: () => getAnimateArray('aStar'),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 362,\n      columnNumber: 21\n    }\n  }, \" A-star\"), /*#__PURE__*/React.createElement(\"button\", {\n    className: currentAlgo === 'dijkstra' ? 'pathFinder__button-active' : null,\n    onClick: () => getAnimateArray('dijkstra'),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 363,\n      columnNumber: 21\n    }\n  }, \"Dijkstra \"), /*#__PURE__*/React.createElement(\"button\", {\n    className: currentAlgo === 'DFS' ? 'pathFinder__button-active' : null,\n    onClick: () => getAnimateArray('DFS'),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 364,\n      columnNumber: 21\n    }\n  }, \"DFS\"), /*#__PURE__*/React.createElement(\"button\", {\n    className: currentAlgo === 'BFS' ? 'pathFinder__button-active' : null,\n    onClick: () => getAnimateArray('BFS'),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 365,\n      columnNumber: 21\n    }\n  }, \"BFS\"))), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"pathFinder__container\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 368,\n      columnNumber: 13\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"pathFinder__grid\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 370,\n      columnNumber: 17\n    }\n  }, mainGrid.map((row, j) => /*#__PURE__*/React.createElement(\"div\", {\n    className: \"grid__row\",\n    key: j,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 373,\n      columnNumber: 41\n    }\n  }, row.map((node, i) => /*#__PURE__*/React.createElement(Node, {\n    key: i,\n    node: node,\n    handleMouseUp: handleMouseUp,\n    handleMouseDown: handleMouseDown,\n    handleMouseEnter: handleMouseEnter,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 375,\n      columnNumber: 37\n    }\n  }))))), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"indicators\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 384,\n      columnNumber: 17\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"start\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 385,\n      columnNumber: 21\n    }\n  }, /*#__PURE__*/React.createElement(\"i\", {\n    class: \"fas fa-car mr-2\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 386,\n      columnNumber: 25\n    }\n  }), /*#__PURE__*/React.createElement(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 387,\n      columnNumber: 25\n    }\n  }, \"Start Node\")), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"end\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 389,\n      columnNumber: 21\n    }\n  }, /*#__PURE__*/React.createElement(\"i\", {\n    class: \"fas fa-flag-checkered mr-2\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 390,\n      columnNumber: 25\n    }\n  }), /*#__PURE__*/React.createElement(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 391,\n      columnNumber: 25\n    }\n  }, \"End Node\")), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"wall\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 394,\n      columnNumber: 21\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"wall__icon\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 395,\n      columnNumber: 25\n    }\n  }), /*#__PURE__*/React.createElement(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 396,\n      columnNumber: 25\n    }\n  }, \"Wall\")), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"shortestPath\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 398,\n      columnNumber: 21\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"path__icon\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 399,\n      columnNumber: 25\n    }\n  }), /*#__PURE__*/React.createElement(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 400,\n      columnNumber: 25\n    }\n  }, \"Shortest Path\")), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"visited\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 402,\n      columnNumber: 21\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"visited__icon\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 403,\n      columnNumber: 25\n    }\n  }), /*#__PURE__*/React.createElement(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 404,\n      columnNumber: 25\n    }\n  }, \"Visited Node\")))));\n};\n\nexport default PathFinder;","map":{"version":3,"sources":["/Users/uchennaibe/Desktop/algorithm-visualizer/src/path-finder/PathFinder.js"],"names":["React","useEffect","useState","Node","getNodesInShortestPathOrder","dijkstra","aStar","bfs","dfs","motion","useWindowSize","toast","variants","ROWS","CURRENT_START_NODE_ROW","CURRENT_START_NODE_COL","CURRENT_END_NODE_ROW","CURRENT_END_NODE_COL","PathFinder","mainGrid","setMainGrid","mouseIsPressed","setMouseIsPressed","isStartNode","setIsStartNode","isEndNode","setIsEndNode","COLS","SET_COLS","alreadyRan","setAlreadyRan","notified","setNotified","currentAlgo","setCurrentAlgo","prevNodeIsWall","setPrevNodeIsWall","createNode","row","col","isStart","isEnd","distance","Infinity","isVisited","previousNode","isWall","f","g","h","createInitialGrid","temp_grid","currentRow","push","window","innerWidth","warn","autoClose","width","handleMouseDown","newGrid","getNewGridWallToggled","handleMouseEnter","getNewStart","getNewEnd","handleMouseUp","getAnimateArray","grid","slice","node","newNode","new_node","prev_node","prevNode","reArrangeGrid","resetColors","nodes","document","getElementsByClassName","i","length","classList","remove","resetGrid","animateShortestPath","nodesInShortestPathOrder","setTimeout","getElementById","add","animateTraversal","visitedNodesInOrder","undefined","info","position","reRun","algorithm","startNode","endNode","success","dark","closeButton","map","j"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport Node from './node/Node';\nimport './pathFinder.css'\nimport { getNodesInShortestPathOrder, dijkstra } from './pathFinder-algos/dijkstra';\nimport { aStar } from './pathFinder-algos/aStar';\nimport { bfs } from './pathFinder-algos/bfs';\nimport { dfs } from './pathFinder-algos/dfs';\nimport { motion } from 'framer-motion'\nimport useWindowSize from '../hooks/windowResize';\nimport { toast } from 'react-toastify';\nimport { variants } from '../framer motion/variants';\n\nvar ROWS = 13;\n// var COLS = 25;\n\nvar CURRENT_START_NODE_ROW = 0;\nvar CURRENT_START_NODE_COL = 8;\nvar CURRENT_END_NODE_ROW = 8;\nvar CURRENT_END_NODE_COL = 0;\n\n\nconst PathFinder = () => {\n\n    const [mainGrid, setMainGrid] = useState([])\n    const [mouseIsPressed, setMouseIsPressed] = useState(false)\n    const [isStartNode, setIsStartNode] = useState(false);\n    const [isEndNode, setIsEndNode] = useState(false);\n    //TODO different cols for different screen\n    const [COLS, SET_COLS] = useState(15);\n    const [alreadyRan, setAlreadyRan] = useState(false); // false if the algo is running first time\n    // else if the algorithm is already ran ; set it true and remove all the node's distance\n    const [notified, setNotified] = useState(false)\n    // const [algoDone, setAlgoDone] = useState(false)\n    const [currentAlgo, setCurrentAlgo] = useState(null)\n\n    const [prevNodeIsWall, setPrevNodeIsWall] = useState(false);\n\n\n\n    const createNode = (row, col) => {\n        return {\n            row,\n            col,\n            isStart: row === CURRENT_START_NODE_ROW && col === CURRENT_START_NODE_COL,\n            isEnd: row === CURRENT_END_NODE_ROW && col === CURRENT_END_NODE_COL,\n            distance: Infinity,\n            isVisited: false,\n            previousNode: null,\n            isWall: false,\n            // for aStar algorithm\n            f: 0,\n            g: 0,\n            h: 0,\n        }\n    }\n\n    const createInitialGrid = () => {\n        let temp_grid = []\n        for (let row = 0; row < ROWS; row++) {\n            var currentRow = []\n            for (let col = 0; col < COLS; col++) {\n                currentRow.push(createNode(row, col))\n            }\n            temp_grid.push(currentRow)\n        }\n        return temp_grid\n    }\n\n    //component did mount\n    useEffect(() => {\n        if (window.innerWidth < 500 && !notified) {\n            toast.warn('Seems like you are using this app in mobile :( Open this app in large screen to get the best experience :)',\n                { autoClose: false })\n        }\n        setNotified(true)\n        setMainGrid(createInitialGrid())\n    }, [COLS])\n    const [width] = useWindowSize()\n    if (width < 500 && COLS !== 15) {\n        SET_COLS(15)\n    }\n    else if (width >= 500 && width <= 1024 && COLS !== 20) {\n        SET_COLS(20)\n    }\n    else if (width > 1024 && COLS !== 25) {\n        SET_COLS(25)\n    }\n\n\n\n    //! MOUSE DOWN -> MOUSE ENTER -> MOUSE UP\n    // MOUSE DOWN : if the node is a start or end node(user wants to set a new start/end node),\n    // then we need to remove* the current start node add the new start node\n    // BUT , if it is neither a start or end node,then convert it to a wall or toggle it\n    const handleMouseDown = (row, col) => {\n        var newGrid;\n        // check if the element to be dragged is a start or end node\n        if (row === CURRENT_START_NODE_ROW && col === CURRENT_START_NODE_COL)\n            setIsStartNode(true); //set the state variable (flag)\n        else if (row === CURRENT_END_NODE_ROW && col === CURRENT_END_NODE_COL)\n            setIsEndNode(true); //set the state variable(flag)\n        else {\n            // else toggle isWall property of that node and update the mainGrid\n            newGrid = getNewGridWallToggled(mainGrid, row, col)\n            setMainGrid(newGrid)\n        }\n        // set mouseIsPressed flag is true;now if user hover over any nodes; that will converted\n        // to a start node or end node or a wall (toggled)\n        setMouseIsPressed(true)\n    }\n\n    const handleMouseEnter = (row, col) => {\n        let newGrid;\n\n        if (!mouseIsPressed) return // return if mousePressed flag is not true (down first)\n\n        if (isStartNode === true) {\n            newGrid = getNewStart(mainGrid, row, col)\n        }\n        else if (isEndNode === true)\n            newGrid = getNewEnd(mainGrid, row, col)\n        else\n            newGrid = getNewGridWallToggled(mainGrid, row, col)\n\n        // update the mainGrid\n        setMainGrid(newGrid)\n    }\n\n    // when leave the mouse , reset the flags to false\n    const handleMouseUp = () => {\n        setMouseIsPressed(false)\n\n        if ((isStartNode || isEndNode) && alreadyRan) {\n            getAnimateArray(currentAlgo)\n        }\n\n        setIsStartNode(false)\n        setIsEndNode(false)\n    }\n\n    const getNewGridWallToggled = (grid, row, col) => {\n        const newGrid = grid.slice()\n        const node = newGrid[row][col]\n        const newNode = {\n            ...node,\n            isWall: !node.isWall\n        }\n        newGrid[row][col] = newNode\n        return newGrid\n    }\n    // toggle the start when dragged\n    const getNewStart = (grid, row, col) => {\n\n        const newGrid = grid.slice()\n        const new_node = newGrid[row][col]\n        const prev_node = newGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL]\n\n        const prevNode = {\n            ...prev_node,\n            isStart: false,\n            isWall: prevNodeIsWall\n        }\n\n        setPrevNodeIsWall(new_node.isWall)\n\n        const newNode = {\n            ...new_node,\n            isWall: false,\n            isStart: true,\n        }\n        newGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL] = prevNode;\n        newGrid[row][col] = newNode\n        //  console.log(newGrid);\n\n\n        // update previous variables with current row and current col\n\n        CURRENT_START_NODE_ROW = row\n        CURRENT_START_NODE_COL = col\n\n        return newGrid\n    }\n\n    const getNewEnd = (grid, row, col) => {\n        const newGrid = grid.slice()\n        const new_node = newGrid[row][col]\n        const prev_node = newGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL]\n        //previous node\n        const prevNode = {\n            ...prev_node,\n            isEnd: false,\n            isWall: prevNodeIsWall\n        }\n        setPrevNodeIsWall(new_node.isWall)\n\n        const newNode = {\n            ...new_node,\n            isWall: false,\n            isEnd: true,\n        }\n        newGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL] = prevNode;\n        newGrid[row][col] = newNode\n\n        // update previous variables with current row and current col\n\n        CURRENT_END_NODE_ROW = row\n        CURRENT_END_NODE_COL = col\n        return newGrid\n    }\n\n    const reArrangeGrid = (grid) => {\n        // make sure don't reset the walls\n        const newGrid = grid.slice()\n        let node;\n        for (let row = 0; row < ROWS; row++) {\n            for (let col = 0; col < COLS; col++) {\n                node = newGrid[row][col]\n                const newNode = {\n                    ...node,\n                    distance: Infinity,\n                    isVisited: false,\n                    previousNode: null\n                }\n                newGrid[row][col] = newNode\n            }\n        }\n        return newGrid\n    }\n\n    const resetColors = () => {\n        const nodes = document.getElementsByClassName(\"node\");\n        for (let i = 0; i < nodes.length; i++) {\n            nodes[i].classList.remove(\"node-visited\")\n            nodes[i].classList.remove(\"node-shortest-path\")\n        }\n    }\n\n    const resetGrid = () => {\n        setMainGrid(createInitialGrid())\n        resetColors()\n\n    }\n    const animateShortestPath = (nodesInShortestPathOrder) => {\n\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n\n            setTimeout(() => {\n                const { row, col } = nodesInShortestPathOrder[i]\n                document.getElementById(`node-${row}-${col}`).classList.add('node-shortest-path')\n\n            }, i * 100)\n        }\n\n    }\n    const animateTraversal = (visitedNodesInOrder, nodesInShortestPathOrder = undefined) => {\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\n\n            setTimeout(() => {\n                if (i === visitedNodesInOrder.length - 1) {\n                    if (nodesInShortestPathOrder)\n                        animateShortestPath(nodesInShortestPathOrder)\n                }\n            }, i * 20)\n            setTimeout(() => {\n                const { row, col } = visitedNodesInOrder[i]\n                document.getElementById(`node-${row}-${col}`).classList.add('node-visited')\n            }, i * 20)\n\n        }\n        if (!nodesInShortestPathOrder) {\n            toast.info('No path found ðŸ¹', {\n                position: 'top-center'\n            })\n        }\n    }\n    //TODO Re Re Re Re Re ................... rename the functions :(\n    const reRun = () => {\n        resetColors();\n        setMainGrid(reArrangeGrid(mainGrid));\n    }\n    //TODO notify when path is not found \n\n    const getAnimateArray = (algorithm) => {\n        var startNode, endNode, visitedNodesInOrder, success;\n        if (algorithm === 'dijkstra') {\n            if (alreadyRan) {\n                reRun()\n            }\n            startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL]\n            endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];\n\n            // object destructuring and store in already defined variables\n            ({ visitedNodesInOrder, success } = dijkstra(mainGrid, startNode, endNode))\n            setAlreadyRan(true);\n            setCurrentAlgo('dijkstra')\n\n        }\n        else if (algorithm === 'aStar') {\n            if (alreadyRan) {\n                reRun()\n            }\n            startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL]\n            endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];\n\n            ({ visitedNodesInOrder, success } = aStar(mainGrid, startNode, endNode))\n            setAlreadyRan(true);\n            setCurrentAlgo('aStar')\n\n        }\n        else if (algorithm === 'BFS') {\n            if (alreadyRan) {\n                reRun()\n            }\n            startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL]\n            endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];\n\n            ({ visitedNodesInOrder, success } = bfs(mainGrid, startNode, endNode))\n            setAlreadyRan(true);\n            setCurrentAlgo('BFS')\n\n        }\n\n        else if (algorithm === 'DFS') {\n            if (alreadyRan) {\n                reRun()\n            }\n            startNode = mainGrid[CURRENT_START_NODE_ROW][CURRENT_START_NODE_COL]\n            endNode = mainGrid[CURRENT_END_NODE_ROW][CURRENT_END_NODE_COL];\n\n            ({ visitedNodesInOrder, success } = dfs(mainGrid, startNode, endNode))\n            setAlreadyRan(true);\n            setCurrentAlgo('DFS')\n\n        }\n\n        //console.log(visitedNodesInOrder, success);\n        var nodesInShortestPathOrder;\n\n        if (success) {\n            nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode)\n        }\n        animateTraversal(visitedNodesInOrder, nodesInShortestPathOrder)\n    }\n\n    return (\n        <motion.div className=\"pathFinder\"\n            variants={variants}\n            initial=\"hidden\"\n            animate=\"visible\"\n            exit=\"exit\"\n        >\n            <div className=\"pathFinder__navbar\">\n                <div className=\"util__buttons\">\n                    <button onClick={() => resetGrid()}>Clear Board</button>\n                    <button onClick={() => toast.dark('â›” Not implemented yet', {\n                        position: 'top-center',\n                        closeButton: false,\n                        autoClose: 3000\n                    })}>Start Timer</button>\n                </div>\n                <div className=\"pathFinder__types\">\n                    <button className={currentAlgo === 'aStar' ? 'pathFinder__button-active' : null} onClick={() => getAnimateArray('aStar')}> A-star</button>\n                    <button className={currentAlgo === 'dijkstra' ? 'pathFinder__button-active' : null} onClick={() => getAnimateArray('dijkstra')}>Dijkstra </button>\n                    <button className={currentAlgo === 'DFS' ? 'pathFinder__button-active' : null} onClick={() => getAnimateArray('DFS')}>DFS</button>\n                    <button className={currentAlgo === 'BFS' ? 'pathFinder__button-active' : null} onClick={() => getAnimateArray('BFS')}>BFS</button>\n                </div>\n            </div>\n            <div className=\"pathFinder__container\">\n\n                <div className=\"pathFinder__grid\">\n                    {\n                        mainGrid.map(\n                            (row, j) => <div className=\"grid__row\" key={j}>\n                                {row.map((node, i) =>\n                                    <Node key={i} node={node}\n                                        handleMouseUp={handleMouseUp}\n                                        handleMouseDown={handleMouseDown}\n                                        handleMouseEnter={handleMouseEnter} />\n                                )}\n                            </div>\n                        )\n                    }\n                </div>\n                <div className=\"indicators\">\n                    <div className=\"start\">\n                        <i class=\"fas fa-car mr-2\"></i>\n                        <strong>Start Node</strong>\n                    </div>\n                    <div className=\"end\">\n                        <i class=\"fas fa-flag-checkered mr-2\"></i>\n                        <strong>End Node</strong>\n                    </div>\n\n                    <div className=\"wall\">\n                        <div className=\"wall__icon\"></div>\n                        <strong>Wall</strong>\n                    </div>\n                    <div className=\"shortestPath\">\n                        <div className=\"path__icon\"></div>\n                        <strong>Shortest Path</strong>\n                    </div>\n                    <div className=\"visited\">\n                        <div className=\"visited__icon\"></div>\n                        <strong>Visited Node</strong>\n                    </div>\n                </div>\n            </div>\n        </motion.div>\n    );\n};\n\nexport default PathFinder;"]},"metadata":{},"sourceType":"module"}